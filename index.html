<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animalysson.io - Brasil Geogr√°fico Completo</title>
    <style>
        /* ===========================
           ESTILOS UNIFICADOS
           =========================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            user-select: none;
        }

        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 3px black, 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: none;
            z-index: 100;
        }

        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            max-width: 300px;
        }

        #player-info {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        #tile-info {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            color: #ffd700;
        }

        #player-name-display {
            font-size: 18px;
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }

        #controls-info {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            line-height: 1.6;
        }

        #slope-indicator {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 14px;
            display: none;
            margin-bottom: 10px;
        }

        #chat-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 400px;
            z-index: 10;
        }

        #chat-messages {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: white;
        }

        .chat-message {
            margin-bottom: 5px;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .chat-message strong {
            color: #667eea;
        }

        #chat-input-container {
            display: flex;
        }

        #chat-input {
            flex: 1;
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 14px;
        }

        #chat-input:focus {
            outline: none;
            border-color: #764ba2;
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .menu-box {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: menuSlideIn 0.3s ease-out;
        }

        @keyframes menuSlideIn {
            from { opacity: 0; transform: scale(0.9) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .menu-box h2 {
            margin-bottom: 30px;
            color: #667eea;
            font-size: 2em;
        }

        .menu-box button {
            display: block;
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            font-size: 1.1em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .menu-box button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        #chat-messages::-webkit-scrollbar { width: 6px; }
        #chat-messages::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); border-radius: 10px; }
        #chat-messages::-webkit-scrollbar-thumb { background: #667eea; border-radius: 10px; }
        #chat-messages::-webkit-scrollbar-thumb:hover { background: #764ba2; }

        /* Hotbar HUD */
        #hotbar-container {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .hotbar-slot {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            opacity: 0.6;
        }

        .hotbar-slot.active {
            opacity: 1;
            background: rgba(255, 255, 255, 0.15);
            border-color: #4facfe;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.4);
            transform: scale(1.1) translateY(-5px);
        }

        .hotbar-slot.active::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background: #4facfe;
            border-radius: 50%;
            box-shadow: 0 0 10px #4facfe;
        }

        .world-label {
            position: absolute;
            font-family: 'Verdana', sans-serif;
            font-weight: bold;
            color: #55f;
            text-shadow: 1px 0px 0px #000, -1px 0px 0px #000, 0px 1px 0px #000, 0px -1px 0px #000;
            font-size: 16px;
            transform: translate(-50%, -50%);
            display: none;
            pointer-events: none;
        }

        /* Wurm UI Elements */
        #action-bar-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #555;
            border-radius: 10px;
            display: none;
            z-index: 90;
        }
        #action-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            width: 0%;
            border-radius: 10px;
            transition: width 0.1s linear;
        }
        #inventory-display { 
            position: fixed; 
            bottom: 40px; 
            right: 20px; 
            color: white; 
            text-align: right; 
            font-family: monospace; 
            text-shadow: 1px 1px 0 #000; 
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
        }

        /* Save Manager Styles */
        #save-manager {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            backdrop-filter: blur(5px);
        }
        .save-list-container {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 10px;
            background: #f9f9f9;
        }
        .save-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #ddd;
            background: white;
            margin-bottom: 5px;
            border-radius: 4px;
        }
        .save-name { 
            font-weight: bold; 
            color: #333; 
            text-align: left; 
            cursor: pointer;
        }
        .save-name:hover {
            color: #667eea;
        }
        .save-actions button {
            width: auto;
            padding: 5px 10px;
            margin-left: 5px;
            font-size: 0.8em;
            display: inline-block;
            margin-bottom: 0;
        }
        .btn-load { 
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%) !important; 
            color: #000 !important; 
        }
        .btn-delete { 
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%) !important; 
        }
        .btn-rename { 
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%) !important; 
            color: #333 !important; 
        }
        
        /* Modal de Configura√ß√£o do Mundo */
        #world-config-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            backdrop-filter: blur(10px);
        }

        .config-box {
            background: white;
            padding: 40px;
            border-radius: 20px;
            width: 600px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: menuSlideIn 0.3s ease-out;
        }

        .config-box h2 {
            margin-bottom: 25px;
            color: #667eea;
            font-size: 2em;
            text-align: center;
        }

        .config-section {
            margin-bottom: 25px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .config-section h3 {
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .config-group {
            margin-bottom: 15px;
        }

        .config-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #444;
        }

        .config-value {
            float: right;
            color: #667eea;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 10px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            vertical-align: middle;
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            margin-top: 5px;
        }

        .config-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }

        .config-buttons button {
            flex: 1;
            padding: 15px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        #btn-generate-world {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: #000;
        }

        #btn-cancel-config {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .preview-image {
            width: 100%;
            height: 150px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 10px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.2em;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .biome-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        .biome-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .biome-label {
            font-size: 12px;
            color: #666;
            margin-left: 5px;
        }

        .biome-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        #debug-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: lime;
            background: rgba(0,0,0,0.8);
            padding: 5px;
            pointer-events: none;
            white-space: pre;
            font-family: monospace;
            z-index: 9999;
            display:none;
        }

        /* Ajustes para telas menores */
        @media (max-width: 768px) {
            #hud {
                max-width: 250px;
                font-size: 12px;
                top: 10px;
                left: 10px;
            }
            
            #hotbar-container {
                top: 80px;
                right: 10px;
                transform: scale(0.9);
            }
            
            #chat-container {
                width: 300px;
                bottom: 10px;
                left: 10px;
            }
            
            #inventory-display {
                bottom: 10px;
                right: 10px;
                font-size: 12px;
                padding: 8px;
            }
            
            .config-box {
                padding: 20px;
                width: 95%;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <div id="hud">
            <div id="player-info" style="display: none;">
                <span id="player-name-display"></span>
                <span id="position-display">X: 0, Y: 0, Z: 0</span>
            </div>
            <div id="tile-info">Olhando: -</div>
            
            <div id="slope-indicator">Inclina√ß√£o: 0/20</div>

            <div id="controls-info" style="display: block;">
                <strong>Controles:</strong><br>
                WASD - Mover | Shift - Correr | Espa√ßo - Pular<br>
                <span style="color: #ffd700;">üñ±Ô∏è Mouse - Olhar/Mirar</span><br>
                Clique Esq/Dir - Terraformar | ENTER - Chat | ESC - Menu<br>
                <span style="color: #ff9900;">‚ö†Ô∏è Inclina√ß√£o m√°xima configur√°vel</span>
            </div>

            <!-- Labels Flutuantes do Mundo -->
            <div id="world-labels" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 1000;">
                <div id="cursor-label" class="world-label" style="color: #ffff00; font-size: 16px; font-weight: bold; text-shadow: 1px 1px 2px black;"></div>
            </div>

            <!-- Wurm UI -->
            <div id="action-bar-container"><div id="action-bar-fill"></div><div style="position:absolute; width:100%; text-align:center; top:-25px; color:white; font-weight:bold; text-shadow:1px 1px 0 #000;" id="action-text">A√ß√£o</div></div>
            <div id="inventory-display">
                <div>Terra: <span id="inv-dirt">0</span></div>
                <div>Areia: <span id="inv-sand">0</span></div>
                <div>Pedras: <span id="inv-rock">0</span></div>
            </div>
        </div>

        <div id="chat-container">
            <div id="chat-messages"></div>
            <div id="chat-input-container" style="display: none;">
                <input type="text" id="chat-input" placeholder="Digite sua mensagem...">
            </div>
        </div>

        <div id="hotbar-container">
            <div class="hotbar-slot active" id="slot-0" title="M√£os vazias">
                <span class="slot-icon">‚úã</span>
            </div>
            <div class="hotbar-slot" id="slot-1" title="P√°">
                <span class="slot-icon">ü•Ñ</span>
            </div>
            <div class="hotbar-slot" id="slot-2" title="Picareta">
                <span class="slot-icon">‚õèÔ∏è</span>
            </div>
        </div>

        <div id="menu" style="display: none;">
            <div class="menu-box">
                <h2>Menu</h2>
                <button id="resume-btn">Continuar</button>
                <button id="open-saves-btn">Gerenciar Saves</button>
            </div>
        </div>

        <!-- Modal de Configura√ß√£o do Mundo -->
        <div id="world-config-modal">
            <div class="config-box">
                <h2>Configura√ß√µes do Mundo</h2>
                
                <div class="preview-image" id="world-preview">
                    Gerando visualiza√ß√£o...
                </div>
                
                <div class="config-section">
                    <h3>‚öôÔ∏è Configura√ß√µes Gerais</h3>
                    <div class="config-group">
                        <label class="config-label">
                            Tamanho do Mapa: <span class="config-value" id="map-size-value">200</span>
                        </label>
                        <input type="range" id="map-size-slider" min="100" max="400" step="20" value="200">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Pequeno</span>
                            <span style="float:right">Grande</span>
                        </div>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Intensidade do Relevo: <span class="config-value" id="relief-value">50%</span>
                        </label>
                        <input type="range" id="relief-slider" min="10" max="100" value="50">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Plano</span>
                            <span style="float:right">Montanhoso</span>
                        </div>
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>üèîÔ∏è Controle de Terreno</h3>
                    <div class="config-group">
                        <label class="config-label">
                            Suaviza√ß√£o do Mapa: <span class="config-value" id="smooth-value">3</span>
                        </label>
                        <input type="range" id="smooth-slider" min="1" max="10" value="3">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Rugoso</span>
                            <span style="float:right">Suave</span>
                        </div>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Inclina√ß√£o M√°xima: <span class="config-value" id="slope-value">20</span>
                        </label>
                        <input type="range" id="slope-slider" min="5" max="40" value="20">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Suave</span>
                            <span style="float:right">√çngreme</span>
                        </div>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Transi√ß√£o entre Biomas: <span class="config-value" id="blend-value">3</span>
                        </label>
                        <input type="range" id="blend-slider" min="1" max="10" value="3">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Definida</span>
                            <span style="float:right">Suave</span>
                        </div>
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>üåé Recursos Naturais</h3>
                    <div class="config-group">
                        <label class="config-label">
                            <input type="checkbox" id="rivers-checkbox" checked> Gerar Rios
                        </label>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            <input type="checkbox" id="ocean-checkbox" checked> Incluir Oceano
                        </label>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Densidade de Vegeta√ß√£o: <span class="config-value" id="veg-value">70%</span>
                        </label>
                        <input type="range" id="veg-slider" min="0" max="100" value="70">
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>üéÆ Configura√ß√µes de Jogo</h3>
                    <div class="config-group">
                        <label class="config-label">
                            Ponto de In√≠cio:
                            <select id="start-region">
                                <option value="random">Aleat√≥rio</option>
                                <option value="centro">Centro-Oeste (Bras√≠lia)</option>
                                <option value="sudeste">Sudeste (S√£o Paulo)</option>
                                <option value="norte">Norte (Amaz√¥nia)</option>
                                <option value="nordeste">Nordeste (Bahia)</option>
                                <option value="sul">Sul (Rio Grande do Sul)</option>
                            </select>
                        </label>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            <input type="checkbox" id="reforestation-checkbox" checked> Reflorestamento Autom√°tico
                        </label>
                    </div>
                </div>
                
                <div class="biome-preview">
                    <div class="biome-item">
                        <div class="biome-color" style="background: #0a5"></div>
                        <span class="biome-label">Amaz√¥nia</span>
                    </div>
                    <div class="biome-item">
                        <div class="biome-color" style="background: #da5"></div>
                        <span class="biome-label">Cerrado</span>
                    </div>
                    <div class="biome-item">
                        <div class="biome-color" style="background: #b85"></div>
                        <span class="biome-label">Caatinga</span>
                    </div>
                    <div class="biome-item">
                        <div class="biome-color" style="background: #0c5"></div>
                        <span class="biome-label">Mata Atl√¢ntica</span>
                    </div>
                    <div class="biome-item">
                        <div class="biome-color" style="background: #0af"></div>
                        <span class="biome-label">Oceano</span>
                    </div>
                </div>
                
                <div class="config-buttons">
                    <button id="btn-cancel-config">Cancelar</button>
                    <button id="btn-generate-world">Gerar Mundo</button>
                </div>
            </div>
        </div>

        <div id="save-manager" style="display: none;">
            <div class="menu-box" style="width: 500px; max-width: 90%;">
                <h2>Saves</h2>
                <div id="save-list" class="save-list-container"></div>
                
                <div style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 10px;">
                    <h3>Novo Jogo / Salvar</h3>
                    <div style="display: flex; gap: 5px; justify-content: center; margin-bottom: 10px;">
                        <input type="text" id="save-name-input" placeholder="Nome do Save" style="padding: 8px; border-radius: 5px; border: 1px solid #ccc; flex: 1;">
                    </div>
                    <div style="display: flex; gap: 5px; justify-content: center;">
                        <button id="btn-open-world-config" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); font-size: 0.9em;">Novo Mundo Personalizado</button>
                        <button id="btn-save-current" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 0.9em;">Salvar Atual</button>
                    </div>
                </div>
                
                <button id="close-save-manager" style="margin-top: 15px; background: #666;">Voltar</button>
            </div>
        </div>

        <div id="debug-overlay">Debug Info</div>
        <div id="crosshair">+</div>
    </div>

    <!-- Three.js via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * ============================================================================
         * SISTEMA GEOGR√ÅFICO COMPLETO DO BRASIL - VERS√ÉO UNIFICADA
         * Combina gera√ß√£o de mundo configur√°vel com terreno geogr√°fico realista
         * ============================================================================
         */
        
        // Configura√ß√µes padr√£o
        let MAP_SIZE = 200;
        let mapSize = MAP_SIZE;
        
        // Vari√°veis do terreno
        let heightMap = [];
        let rockHeightMap = [];
        let terrainTypeMap = [];
        let compactionMap = [];
        let dirtTimestamps = {};
        let biomeMap = [];
        
        // Configura√ß√µes do mundo (valores padr√£o)
        let worldConfig = {
            mapSize: 200,
            reliefIntensity: 50,
            smoothIterations: 3,
            maxSlope: 20,
            biomeBlend: 3,
            generateRivers: true,
            includeOcean: true,
            vegetationDensity: 70,
            startRegion: 'random',
            autoReforestation: true
        };
        
        // Constantes para tipos de bioma
        const BIOME_AMAZONIA = 0;
        const BIOME_CERRADO = 1;
        const BIOME_CAATINGA = 2;
        const BIOME_MATA_ATLANTICA = 3;
        const BIOME_PAMPA = 4;
        const BIOME_PANTANAL = 5;
        const BIOME_COSTEIRA = 6;
        const BIOME_OCEANO = 7;
        const BIOME_MONTANHA = 8;
        
        // Constantes para sistema de inclina√ß√£o
        const SLIP_START_SLOPE = 15;
        const MAX_CLIMB_SLOPE = 25;
        const CRITICAL_SLOPE = 30;
        const WARNING_COOLDOWN = 5000; // 5 segundos
        
        // Fun√ß√£o principal para gerar o terreno do Brasil com configura√ß√µes
        function generateBrazilTerrain(config = worldConfig) {
            console.log('Gerando terreno geogr√°fico com configura√ß√µes:', config);
            
            // Aplicar configura√ß√µes
            mapSize = config.mapSize;
            MAP_SIZE = mapSize;
            
            // Inicializar arrays
            heightMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(0));
            rockHeightMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(0));
            terrainTypeMap = Array.from({ length: mapSize - 1 }, () => Array(mapSize - 1).fill(0));
            compactionMap = Array.from({ length: mapSize - 1 }, () => Array(mapSize - 1).fill(0));
            biomeMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(BIOME_OCEANO));
            
            // Gerar terreno baseado na geografia real do Brasil
            for (let x = 0; x < mapSize; x++) {
                for (let y = 0; y < mapSize; y++) {
                    // Coordenadas normalizadas (0 a 1)
                    const nx = x / mapSize;
                    const ny = y / mapSize;
                    
                    // Determinar a regi√£o e bioma
                    const regionInfo = getBrazilRegionAndBiome(nx, ny);
                    const biome = regionInfo.biome;
                    
                    // Calcular altura baseado na regi√£o com intensidade ajust√°vel
                    const baseHeight = calculateBrazilHeight(nx, ny, regionInfo);
                    const intensity = config.reliefIntensity / 100;
                    
                    // Aplicar intensidade do relevo
                    let height = baseHeight * intensity;
                    
                    // Ru√≠do fractal ajustado pela intensidade
                    let noise = fractalNoise(nx * 5, ny * 5, 4) * 50 * intensity;
                    height += noise;
                    
                    // Altura da rocha (sempre abaixo do solo)
                    let rockHeight = height - 3 - Math.random() * 2;
                    
                    // Ajustes espec√≠ficos por bioma
                    if (biome === BIOME_PANTANAL) {
                        rockHeight = height - 1;
                    } else if (biome === BIOME_MONTANHA) {
                        rockHeight = height - 5;
                    }
                    
                    // Garantir valores v√°lidos
                    heightMap[x][y] = Math.max(-10, Math.round(height));
                    rockHeightMap[x][y] = Math.round(rockHeight);
                    biomeMap[x][y] = biome;
                }
            }
            
            // Aplicar suaviza√ß√£o m√∫ltipla para transi√ß√µes suaves
            for (let i = 0; i < config.smoothIterations; i++) {
                smoothTerrainAdvanced(1, 2);
            }
            
            // Aplicar restri√ß√£o de inclina√ß√£o durante a gera√ß√£o
            applySlopeConstraint(config.maxSlope);
            
            // Gerar rios principais se configurado
            if (config.generateRivers) {
                generateRivers();
            }
            
            // Aplicar suaviza√ß√£o adicional ap√≥s rios
            smoothTerrain(1);
            
            // Aplicar filtro de suaviza√ß√£o nas bordas dos biomas
            applyBiomeBlending(config.biomeBlend);
            
            // Gerar tipos de terreno baseados no bioma e altura
            generateTerrainTypesFromBiomes(config.vegetationDensity);
            
            console.log('Terreno geogr√°fico do Brasil gerado com sucesso!');
        }
        
        // Determina a regi√£o geogr√°fica e bioma de um ponto
        function getBrazilRegionAndBiome(nx, ny) {
            // nx: 0 (Oeste) a 1 (Leste)
            // ny: 0 (Norte) a 1 (Sul)
            
            // Fun√ß√£o de transi√ß√£o suave entre regi√µes
            const smoothTransition = (value, threshold, width = 0.05) => {
                return Math.max(0, Math.min(1, (value - (threshold - width/2)) / width));
            };
            
            // 1. REGI√ÉO NORTE (Amaz√¥nia)
            const isNorth = smoothTransition(ny, 0.45, 0.1) < 0.5;
            const isWest = smoothTransition(nx, 0.15, 0.1) > 0.5;
            const isEast = smoothTransition(nx, 0.85, 0.1) < 0.5;
            
            if (isNorth && isWest && isEast) {
                if (ny > 0.75 * nx - 0.4) {
                    // Rio Amazonas (vale central)
                    const amazonRiverY = 0.25 + 0.05 * Math.sin(nx * 8);
                    const riverDist = Math.abs(ny - amazonRiverY);
                    if (riverDist < 0.04) {
                        return { region: 'NORTE', subregion: 'RIO_AMAZONAS', biome: BIOME_AMAZONIA };
                    }
                    
                    // Planalto das Guianas (extremo norte)
                    if (ny < 0.2) {
                        const plateauMix = 1 - smoothTransition(ny, 0.15, 0.05);
                        if (plateauMix > 0.7) {
                            return { region: 'NORTE', subregion: 'PLANALTO_GUIANAS', biome: BIOME_MONTANHA };
                        }
                    }
                    
                    // Floresta Amaz√¥nica principal
                    return { region: 'NORTE', subregion: 'FLORESTA_AMAZONICA', biome: BIOME_AMAZONIA };
                }
            }
            
            // 2. REGI√ÉO NORDESTE
            const isNortheastY = smoothTransition(ny, 0.35, 0.1) > 0.5 && smoothTransition(ny, 0.65, 0.1) < 0.5;
            const isNortheastX = smoothTransition(nx, 0.65, 0.1) > 0.5;
            
            if (isNortheastY && isNortheastX) {
                // Litoral Nordestino
                const coastFactor = smoothTransition(nx, 0.85, 0.05);
                if (coastFactor > 0.7) {
                    return { region: 'NORDESTE', subregion: 'LITORAL', biome: BIOME_COSTEIRA };
                }
                
                // Chapada Diamantina (√°rea elevada)
                if (nx > 0.72 && nx < 0.82 && ny > 0.4 && ny < 0.5) {
                    const chapadaFactor = 1 - Math.sqrt(Math.pow((nx-0.77)/0.05, 2) + Math.pow((ny-0.45)/0.05, 2));
                    if (chapadaFactor > 0.5) {
                        return { region: 'NORDESTE', subregion: 'CHAPADA_DIAMANTINA', biome: BIOME_CERRADO };
                    }
                }
                
                // Sert√£o (interior semi√°rido)
                return { region: 'NORDESTE', subregion: 'SERTAO', biome: BIOME_CAATINGA };
            }
            
            // 3. REGI√ÉO CENTRO-OESTE
            const isCenterWestY = smoothTransition(ny, 0.35, 0.1) > 0.5 && smoothTransition(ny, 0.75, 0.1) < 0.5;
            const isCenterWestX = smoothTransition(nx, 0.3, 0.1) > 0.5 && smoothTransition(nx, 0.7, 0.1) < 0.5;
            
            if (isCenterWestY && isCenterWestX) {
                // Pantanal (oeste)
                if (nx < 0.45 && ny > 0.55) {
                    const pantanalFactor = 1 - Math.sqrt(Math.pow((nx-0.4)/0.1, 2) + Math.pow((ny-0.6)/0.05, 2));
                    if (pantanalFactor > 0.3) {
                        return { region: 'CENTRO_OESTE', subregion: 'PANTANAL', biome: BIOME_PANTANAL };
                    }
                }
                
                // Chapada dos Veadeiros (√°rea elevada)
                if (nx > 0.45 && nx < 0.55 && ny > 0.45 && ny < 0.55) {
                    const veadeirosFactor = 1 - Math.sqrt(Math.pow((nx-0.5)/0.05, 2) + Math.pow((ny-0.5)/0.05, 2));
                    if (veadeirosFactor > 0.5) {
                        return { region: 'CENTRO_OESTE', subregion: 'CHAPADA_VEADEIROS', biome: BIOME_MONTANHA };
                    }
                }
                
                // Cerrado (predominante)
                return { region: 'CENTRO_OESTE', subregion: 'CERRADO', biome: BIOME_CERRADO };
            }
            
            // 4. REGI√ÉO SUDESTE
            const isSoutheastY = smoothTransition(ny, 0.45, 0.1) > 0.5 && smoothTransition(ny, 0.75, 0.1) < 0.5;
            const isSoutheastX = smoothTransition(nx, 0.65, 0.1) > 0.5;
            
            if (isSoutheastY && isSoutheastX) {
                // Serra do Mar (litoral)
                if (nx < 0.75) {
                    const serraFactor = smoothTransition(nx, 0.7, 0.05);
                    if (serraFactor < 0.5) {
                        return { region: 'SUDESTE', subregion: 'SERRA_DO_MAR', biome: BIOME_MATA_ATLANTICA };
                    }
                }
                
                // Serra da Mantiqueira (interior montanhoso)
                if (nx > 0.7 && nx < 0.8 && ny > 0.55 && ny < 0.65) {
                    const mantiqueiraFactor = 1 - Math.sqrt(Math.pow((nx-0.75)/0.05, 2) + Math.pow((ny-0.6)/0.05, 2));
                    if (mantiqueiraFactor > 0.5) {
                        return { region: 'SUDESTE', subregion: 'SERRA_MANTIQUEIRA', biome: BIOME_MONTANHA };
                    }
                }
                
                // Planalto Atl√¢ntico
                return { region: 'SUDESTE', subregion: 'PLANALTO_ATLANTICO', biome: BIOME_MATA_ATLANTICA };
            }
            
            // 5. REGI√ÉO SUL
            const isSouth = smoothTransition(ny, 0.65, 0.1) > 0.5;
            const isSouthX = smoothTransition(nx, 0.2, 0.1) > 0.5 && smoothTransition(nx, 0.6, 0.1) < 0.5;
            
            if (isSouth && isSouthX) {
                // Serra Geral (escarpas)
                if (nx < 0.4) {
                    const serraGeralFactor = 1 - Math.abs(nx - 0.35) / 0.05;
                    if (serraGeralFactor > 0.5) {
                        return { region: 'SUL', subregion: 'SERRA_GERAL', biome: BIOME_MATA_ATLANTICA };
                    }
                }
                
                // Pampa (campos do sul)
                if (ny > 0.8) {
                    const pampaFactor = smoothTransition(ny, 0.8, 0.05);
                    if (pampaFactor > 0.7) {
                        return { region: 'SUL', subregion: 'PAMPA', biome: BIOME_PAMPA };
                    }
                }
                
                // Planalto Meridional
                return { region: 'SUL', subregion: 'PLANALTO_MERIDIONAL', biome: BIOME_CERRADO };
            }
            
            // 6. OCEANO (fora do territ√≥rio brasileiro)
            return { region: 'OCEANO', subregion: 'ATLANTICO', biome: BIOME_OCEANO };
        }
        
        // Calcula a altura baseado na regi√£o e caracter√≠sticas geogr√°ficas
        function calculateBrazilHeight(nx, ny, regionInfo) {
            const { region, subregion } = regionInfo;
            let height = 10;
            
            // Ru√≠do fractal para detalhes naturais
            let noise = fractalNoise(nx * 5, ny * 5, 4) * 50;
            
            switch (region) {
                case 'NORTE':
                    if (subregion === 'RIO_AMAZONAS') {
                        // Vale do Rio Amazonas (muito baixo)
                        height = 5 + noise * 0.2;
                    } else if (subregion === 'PLANALTO_GUIANAS') {
                        // Planalto das Guianas (alto)
                        height = 500 + (0.2 - ny) * 1500 + noise * 2;
                        // Pico da Neblina (ponto mais alto do Brasil)
                        if (nx > 0.25 && nx < 0.35 && ny < 0.1) {
                            height += 500 + Math.sin(nx * 30) * 200;
                        }
                    } else {
                        // Floresta Amaz√¥nica (plan√≠cie)
                        height = 50 + noise * 0.8;
                    }
                    break;
                    
                case 'NORDESTE':
                    if (subregion === 'LITORAL') {
                        // Litoral Nordestino (baixo)
                        height = Math.max(5, 100 - (nx - 0.85) * 300 + noise * 0.5);
                    } else if (subregion === 'CHAPADA_DIAMANTINA') {
                        // Chapada Diamantina (montanhoso)
                        height = 800 + Math.sin(nx * 20) * 200 + noise * 2;
                        // Pico do Barbado (ponto mais alto do Nordeste)
                        if (nx > 0.76 && nx < 0.78 && ny > 0.44 && ny < 0.46) {
                            height += 300;
                        }
                    } else {
                        // Sert√£o (planalto semi√°rido)
                        height = 300 + noise;
                    }
                    break;
                    
                case 'CENTRO_OESTE':
                    if (subregion === 'PANTANAL') {
                        // Pantanal (plan√≠cie alagada)
                        height = 80 + noise * 0.3;
                        // √Åreas periodicamente alagadas
                        if (fractalNoise(nx * 10, ny * 10, 2) > 0.3) {
                            height = 50 + noise * 0.2;
                        }
                    } else if (subregion === 'CHAPADA_VEADEIROS') {
                        // Chapada dos Veadeiros (alto)
                        height = 1200 + Math.sin(nx * 25) * 300 + noise * 3;
                    } else {
                        // Cerrado (planalto)
                        height = 500 + noise;
                    }
                    break;
                    
                case 'SUDESTE':
                    if (subregion === 'SERRA_DO_MAR') {
                        // Serra do Mar (montanhas costeiras)
                        const distanceFromCoast = Math.max(0, nx - 0.7);
                        height = 1200 * (1 - distanceFromCoast * 2) + 200;
                        height = Math.max(200, height + noise * 2);
                    } else if (subregion === 'SERRA_MANTIQUEIRA') {
                        // Serra da Mantiqueira (alta montanha)
                        height = 1800 + Math.sin(ny * 30) * 400 + noise * 3;
                        // Pico da Bandeira
                        if (nx > 0.74 && nx < 0.76 && ny > 0.58 && ny < 0.62) {
                            height += 500;
                        }
                    } else {
                        // Planalto Atl√¢ntico
                        height = 800 + noise * 1.5;
                    }
                    break;
                    
                case 'SUL':
                    if (subregion === 'SERRA_GERAL') {
                        // Serra Geral (escarpas)
                        height = 900 + noise * 2;
                        // Arestas da serra
                        if (Math.abs(nx - 0.35) < 0.02) {
                            height += 200;
                        }
                    } else if (subregion === 'PAMPA') {
                        // Pampa (campos planos)
                        height = 100 + noise * 0.5;
                    } else {
                        // Planalto Meridional
                        height = 600 + noise;
                    }
                    break;
                    
                case 'OCEANO':
                default:
                    height = -10 + noise * 2;
                    break;
            }
            
            return Math.max(-15, Math.min(3000, height));
        }
        
        // Ru√≠do fractal para relevo natural
        function fractalNoise(x, y, octaves) {
            let total = 0;
            let frequency = 1;
            let amplitude = 1;
            let maxValue = 0;
            
            for (let i = 0; i < octaves; i++) {
                total += perlinNoise(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return total / maxValue;
        }
        
        // Perlin noise melhorado
        function perlinNoise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            
            const u = fade(x);
            const v = fade(y);
            
            const a = p[X] + Y;
            const b = p[X + 1] + Y;
            
            return lerp(v, lerp(u, grad(p[a], x, y), grad(p[b], x - 1, y)),
                           lerp(u, grad(p[a + 1], x, y - 1), grad(p[b + 1], x - 1, y - 1)));
        }
        
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        
        // Permutation table for Perlin noise
        const p = new Array(512);
        const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,
            140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,
            197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,
            136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,
            122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,
            1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,
            164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,
            255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,
            119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,
            19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,
            193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,
            214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,
            236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
        
        for (let i = 0; i < 256; i++) {
            p[256 + i] = p[i] = permutation[i];
        }
        
        // Aplicar restri√ß√£o de inclina√ß√£o ao terreno gerado
        function applySlopeConstraint(maxSlope) {
            console.log(`Aplicando restri√ß√£o de inclina√ß√£o m√°xima: ${maxSlope}`);
            
            // Criar uma c√≥pia do mapa de altura
            const originalHeight = heightMap.map(row => [...row]);
            let changed = true;
            let iterations = 0;
            const maxIterations = 100;
            
            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;
                
                for (let x = 0; x < mapSize; x++) {
                    for (let y = 0; y < mapSize; y++) {
                        // Verificar todos os 8 vizinhos (incluindo diagonais)
                        const neighbors = [
                            [x + 1, y], [x, y + 1], [x - 1, y], [x, y - 1],
                            [x + 1, y + 1], [x - 1, y + 1], [x + 1, y - 1], [x - 1, y - 1]
                        ];
                        
                        for (const [nx, ny] of neighbors) {
                            if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize) {
                                const diff = heightMap[x][y] - heightMap[nx][ny];
                                
                                if (Math.abs(diff) > maxSlope) {
                                    // Ajuste mais suave: reduzir gradualmente a diferen√ßa
                                    const adjustment = Math.sign(diff) * (Math.abs(diff) - maxSlope) * 0.3;
                                    const newHeight = heightMap[x][y] - adjustment;
                                    
                                    // Garantir que a nova altura n√£o fique abaixo da rocha
                                    if (newHeight > rockHeightMap[x][y] + 0.5) {
                                        heightMap[x][y] = newHeight;
                                        changed = true;
                                    } else {
                                        // Se ficaria abaixo da rocha, ajustar para cima
                                        heightMap[x][y] = rockHeightMap[x][y] + 1;
                                        changed = true;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Aplicar suaviza√ß√£o leve ap√≥s cada itera√ß√£o
                smoothTerrain(1);
            }
            
            console.log(`Restri√ß√£o de inclina√ß√£o aplicada em ${iterations} itera√ß√µes`);
            
            // Garantir que mudan√ßas n√£o sejam muito dr√°sticas
            for (let x = 0; x < mapSize; x++) {
                for (let y = 0; y < mapSize; y++) {
                    const maxChange = 10; // M√°xima mudan√ßa permitida por itera√ß√£o
                    if (Math.abs(heightMap[x][y] - originalHeight[x][y]) > maxChange) {
                        heightMap[x][y] = originalHeight[x][y] + 
                            Math.sign(heightMap[x][y] - originalHeight[x][y]) * maxChange;
                    }
                }
            }
        }
        
        // Suaviza√ß√£o avan√ßada com kernel configur√°vel
        function smoothTerrainAdvanced(iterations, kernelSize = 2) {
            const kernelRadius = Math.floor(kernelSize / 2);
            const kernelWeight = 1.0 / (kernelSize * kernelSize);
            
            for (let iter = 0; iter < iterations; iter++) {
                const newHeightMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(0));
                
                for (let x = 0; x < mapSize; x++) {
                    for (let y = 0; y < mapSize; y++) {
                        let sum = 0;
                        let weightSum = 0;
                        
                        // Aplicar kernel
                        for (let kx = -kernelRadius; kx <= kernelRadius; kx++) {
                            for (let ky = -kernelRadius; ky <= kernelRadius; ky++) {
                                const nx = x + kx;
                                const ny = y + ky;
                                
                                if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize) {
                                    // Peso gaussiano para centro do kernel
                                    const distance = Math.sqrt(kx*kx + ky*ky);
                                    const weight = Math.exp(-distance * distance / (2 * kernelRadius * kernelRadius));
                                    
                                    sum += heightMap[nx][ny] * weight;
                                    weightSum += weight;
                                }
                            }
                        }
                        
                        newHeightMap[x][y] = Math.round(sum / weightSum);
                    }
                }
                
                heightMap = newHeightMap;
            }
        }
        
        // Suavizar o terreno (vers√£o original)
        function smoothTerrain(iterations) {
            for (let iter = 0; iter < iterations; iter++) {
                const newHeightMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(0));
                
                for (let x = 0; x < mapSize; x++) {
                    for (let y = 0; y < mapSize; y++) {
                        let sum = heightMap[x][y];
                        let count = 1;
                        
                        if (x > 0) { sum += heightMap[x-1][y]; count++; }
                        if (x < mapSize-1) { sum += heightMap[x+1][y]; count++; }
                        if (y > 0) { sum += heightMap[x][y-1]; count++; }
                        if (y < mapSize-1) { sum += heightMap[x][y+1]; count++; }
                        
                        newHeightMap[x][y] = Math.round(sum / count);
                    }
                }
                
                heightMap = newHeightMap;
            }
        }
        
        // Aplicar suaviza√ß√£o nas transi√ß√µes de biomas
        function applyBiomeBlending(blendStrength) {
            console.log(`Aplicando suaviza√ß√£o de biomas (for√ßa: ${blendStrength})`);
            
            if (blendStrength <= 1) return; // Sem suaviza√ß√£o
            
            // Criar c√≥pia do mapa de biomas
            const originalBiomes = biomeMap.map(row => [...row]);
            
            for (let x = 0; x < mapSize; x++) {
                for (let y = 0; y < mapSize; y++) {
                    const currentBiome = originalBiomes[x][y];
                    let biomeCounts = new Array(9).fill(0);
                    
                    // Contar biomas vizinhos
                    const radius = Math.min(blendStrength, 5);
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dy = -radius; dy <= radius; dy++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize) {
                                const distance = Math.sqrt(dx*dx + dy*dy);
                                if (distance <= radius) {
                                    const neighborBiome = originalBiomes[nx][ny];
                                    // Peso baseado na dist√¢ncia (mais perto = mais peso)
                                    const weight = 1.0 - (distance / radius);
                                    biomeCounts[neighborBiome] += weight;
                                }
                            }
                        }
                    }
                    
                    // Se houver biomas misturados, determinar o dominante
                    let maxCount = 0;
                    let dominantBiome = currentBiome;
                    for (let i = 0; i < biomeCounts.length; i++) {
                        if (biomeCounts[i] > maxCount) {
                            maxCount = biomeCounts[i];
                            dominantBiome = i;
                        }
                    }
                    
                    // Aplicar transi√ß√£o suave (apenas se n√£o for oceano para manter costa definida)
                    if (currentBiome !== BIOME_OCEANO || dominantBiome !== BIOME_OCEANO) {
                        biomeMap[x][y] = dominantBiome;
                    }
                }
            }
        }
        
        // Gerar rios principais
        function generateRivers() {
            console.log('Gerando rios principais...');
            
            // 1. Rio Amazonas (oeste para leste no norte)
            for (let x = 0; x < mapSize; x++) {
                const nx = x / mapSize;
                // Trajeto sinuoso do Amazonas
                const riverCenterY = 0.25 + 0.05 * Math.sin(nx * 8);
                const riverY = Math.round(riverCenterY * mapSize);
                
                // Largura do rio (mais largo no meio)
                const riverWidth = Math.round((0.5 + 0.3 * Math.sin(nx * Math.PI)) * 8);
                
                for (let w = -riverWidth; w <= riverWidth; w++) {
                    const y = riverY + w;
                    if (y >= 0 && y < mapSize) {
                        // Baixar a altura para criar o vale do rio (suavemente)
                        const depth = 10 * (1 - Math.pow(Math.abs(w) / riverWidth, 2));
                        heightMap[x][y] = Math.max(-5, heightMap[x][y] - depth);
                        // Marcar como √°rea fluvial no bioma
                        biomeMap[x][y] = BIOME_AMAZONIA;
                    }
                }
            }
            
            // 2. Rio S√£o Francisco (Nordeste/Centro-Oeste)
            for (let x = Math.round(0.6 * mapSize); x < Math.round(0.85 * mapSize); x++) {
                const progress = (x - 0.6 * mapSize) / (0.25 * mapSize);
                const riverY = 0.55 + 0.1 * Math.sin(progress * 4);
                const y = Math.round(riverY * mapSize);
                
                if (y >= 0 && y < mapSize) {
                    const riverWidth = 3;
                    for (let w = -riverWidth; w <= riverWidth; w++) {
                        const currentY = y + w;
                        if (currentY >= 0 && currentY < mapSize) {
                            const depth = 8 * (1 - Math.abs(w) / riverWidth);
                            heightMap[x][currentY] = Math.max(0, heightMap[x][currentY] - depth);
                        }
                    }
                }
            }
            
            // Suavizar √°reas ao redor dos rios
            smoothTerrain(2);
        }
        
        // Gerar tipos de terreno baseados nos biomas com densidade ajust√°vel
        function generateTerrainTypesFromBiomes(vegetationDensity = 70) {
            const vegProb = vegetationDensity / 100;
            
            for (let x = 0; x < mapSize - 1; x++) {
                for (let y = 0; y < mapSize - 1; y++) {
                    const biome = biomeMap[x][y];
                    const h1 = heightMap[x][y];
                    const h2 = heightMap[x+1][y];
                    const h3 = heightMap[x][y+1];
                    const h4 = heightMap[x+1][y+1];
                    const avgH = (h1 + h2 + h3 + h4) / 4;
                    
                    // Verificar se √© rocha
                    const r1 = rockHeightMap[x][y];
                    const r2 = rockHeightMap[x+1][y];
                    const r3 = rockHeightMap[x][y+1];
                    const r4 = rockHeightMap[x+1][y+1];
                    const isRock = (h1 <= r1) && (h2 <= r2) && (h3 <= r3) && (h4 <= r4);
                    
                    let type = 0; // Default: Grama
                    
                    if (isRock) {
                        type = 5; // Rocha
                    } else if (avgH <= 0) {
                        type = 3; // Areia (fundo do mar/praia)
                    } else {
                        // Definir tipo baseado no bioma e altura
                        switch (biome) {
                            case BIOME_AMAZONIA:
                                type = Math.random() < vegProb ? 0 : 1; // Mistura grama/terra
                                if (avgH < 20 && Math.random() > 0.7) type = 3; // √Åreas alagadas
                                break;
                                
                            case BIOME_CERRADO:
                                type = Math.random() > 0.7 ? 1 : 0;
                                if (avgH > 800 && Math.random() > 0.8) type = 4; // Argila em √°reas altas
                                break;
                                
                            case BIOME_CAATINGA:
                                type = Math.random() < 0.8 ? 1 : 2; // Predomin√¢ncia de terra seca
                                break;
                                
                            case BIOME_MATA_ATLANTICA:
                                type = Math.random() < vegProb ? 0 : 1;
                                if (avgH > 1000) type = Math.random() > 0.5 ? 4 : 5;
                                break;
                                
                            case BIOME_PAMPA:
                                type = Math.random() < vegProb ? 0 : 1;
                                break;
                                
                            case BIOME_PANTANAL:
                                type = 3; // Areia/√°reas √∫midas
                                if (avgH < 5 && Math.random() < vegProb) type = 0;
                                break;
                                
                            case BIOME_COSTEIRA:
                                type = avgH < 10 ? 3 : (Math.random() < vegProb ? 0 : 1);
                                break;
                                
                            case BIOME_MONTANHA:
                                if (avgH > 1500) {
                                    type = 5; // Rocha exposta
                                } else {
                                    type = Math.random() > 0.7 ? 4 : 0;
                                }
                                break;
                                
                            case BIOME_OCEANO:
                            default:
                                type = 3; // Areia/fundo do mar
                                break;
                        }
                    }
                    
                    terrainTypeMap[x][y] = type;
                }
            }
        }

        /**
         * ============================================================================
         * L√ìGICA DO CLIENTE - JOGO PRINCIPAL
         * ============================================================================
         */
        
        // Vari√°veis do jogo
        let scene, camera, renderer;
        let terrain, waterMesh;
        let selectionHighlight, adjacentBordersHighlight, adjacentTilesHighlight;
        
        // Constantes do jogo
        const TILE_SIZE = 4;
        const METERS_PER_TERRA = 0.1;

        // Invent√°rio e ferramentas
        let selectedSlot = 0;
        let shovelGroup = null;
        let pickaxeGroup = null;
        let armsGroup = null;
        let terraformWarningShown = false;
        let lastWarningTime = 0;

        let player = { x: 100, y: 100, z: 0, name: 'Explorador' };
        let keys = {};
        let mouseDown = { left: false, right: false };
        let currentAction = null; // { type, startTime, duration, target }
        let inventory = { dirt: 0, sand: 0, rock: 0 };

        let terraformTarget = { valid: false };
        let raycaster = new THREE.Raycaster();
        let chatOpen = false;
        let menuOpen = false;
        let currentSlope = 0;

        // C√¢mera
        let isFirstPerson = true;
        let cameraYaw = 0;
        let cameraPitch = 0.3;
        let targetYaw = 0;
        let targetPitch = 0.3;
        let cameraDistance = 15;
        let targetDistance = 15;
        const cameraHeight = 2.5;
        const cameraSmoothness = 0.1;
        const minPitch = -Math.PI / 2.1;
        const maxPitch = Math.PI / 2.1;

        // Movimento
        let characterYaw = 0;
        const moveSpeed = 0.25;
        const runSpeed = 0.45;
        const acceleration = 0.02;
        const friction = 0.92;
        let vx = 0;
        let vz = 0;
        const baseJumpForce = 0.6; // ALTERADO: Aumentado de 0.44 para 0.6
        let verticalVelocity = 0;
        const gravity = 0.022;

        // Inicializa√ß√£o do jogo
        function startGame() {
            initGame();
            setupMenuButtons();
            
            // Iniciar na tela de Saves
            const saveManager = document.getElementById('save-manager');
            saveManager.style.display = 'flex';
            document.getElementById('close-save-manager').style.display = 'none';
            renderSaveList();
            
            // Configurar sliders da modal
            setupWorldConfigSliders();
        }

        startGame();

        // Configurar sliders da modal
        function setupWorldConfigSliders() {
            const sliders = [
                { id: 'map-size-slider', valueId: 'map-size-value', format: v => v },
                { id: 'relief-slider', valueId: 'relief-value', format: v => v + '%' },
                { id: 'smooth-slider', valueId: 'smooth-value', format: v => v },
                { id: 'slope-slider', valueId: 'slope-value', format: v => v },
                { id: 'blend-slider', valueId: 'blend-value', format: v => v },
                { id: 'veg-slider', valueId: 'veg-value', format: v => v + '%' }
            ];
            
            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                
                element.addEventListener('input', function() {
                    valueElement.textContent = slider.format(this.value);
                    updateWorldPreview();
                });
            });
            
            // Checkboxes
            document.getElementById('rivers-checkbox').addEventListener('change', updateWorldPreview);
            document.getElementById('ocean-checkbox').addEventListener('change', updateWorldPreview);
            document.getElementById('reforestation-checkbox').addEventListener('change', updateWorldPreview);
            document.getElementById('start-region').addEventListener('change', updateWorldPreview);
        }
        
        // Atualizar visualiza√ß√£o do mundo
        function updateWorldPreview() {
            const preview = document.getElementById('world-preview');
            const config = getWorldConfigFromUI();
            
            let description = "üåé ";
            description += config.mapSize + "√ó" + config.mapSize + " | ";
            description += "Rel: " + config.reliefIntensity + "% | ";
            description += "Inc: " + config.maxSlope + " | ";
            description += config.generateRivers ? "üåä " : "";
            description += config.includeOcean ? "üåÖ " : "";
            
            preview.textContent = description;
        }
        
        // Obter configura√ß√µes da UI
        function getWorldConfigFromUI() {
            return {
                mapSize: parseInt(document.getElementById('map-size-slider').value),
                reliefIntensity: parseInt(document.getElementById('relief-slider').value),
                smoothIterations: parseInt(document.getElementById('smooth-slider').value),
                maxSlope: parseInt(document.getElementById('slope-slider').value),
                biomeBlend: parseInt(document.getElementById('blend-slider').value),
                generateRivers: document.getElementById('rivers-checkbox').checked,
                includeOcean: document.getElementById('ocean-checkbox').checked,
                vegetationDensity: parseInt(document.getElementById('veg-slider').value),
                startRegion: document.getElementById('start-region').value,
                autoReforestation: document.getElementById('reforestation-checkbox').checked
            };
        }

        function setupMenuButtons() {
            const resumeBtn = document.getElementById('resume-btn');
            const openSavesBtn = document.getElementById('open-saves-btn');
            const menu = document.getElementById('menu');
            const saveManager = document.getElementById('save-manager');
            const closeSaveManagerBtn = document.getElementById('close-save-manager');
            const btnOpenWorldConfig = document.getElementById('btn-open-world-config');
            const btnSaveCurrent = document.getElementById('btn-save-current');
            const btnCancelConfig = document.getElementById('btn-cancel-config');
            const btnGenerateWorld = document.getElementById('btn-generate-world');
            const worldConfigModal = document.getElementById('world-config-modal');

            resumeBtn.onclick = function (e) {
                e.preventDefault();
                e.stopPropagation();
                closeMenu();
                document.getElementById('game-canvas').requestPointerLock();
            };

            openSavesBtn.onclick = function(e) {
                e.preventDefault();
                menu.style.display = 'none';
                saveManager.style.display = 'flex';
                renderSaveList();
                document.getElementById('close-save-manager').style.display = 'block';
            };

            closeSaveManagerBtn.onclick = function() {
                saveManager.style.display = 'none';
                menu.style.display = 'flex';
            };

            btnOpenWorldConfig.onclick = function() {
                saveManager.style.display = 'none';
                worldConfigModal.style.display = 'flex';
                setupWorldConfigSliders();
                updateWorldPreview();
            };

            btnCancelConfig.onclick = function() {
                worldConfigModal.style.display = 'none';
                saveManager.style.display = 'flex';
            };

            btnGenerateWorld.onclick = function() {
                const name = document.getElementById('save-name-input').value.trim();
                if(!name) {
                    alert("Digite um nome para o save antes de gerar o mundo.");
                    return;
                }
                
                // Obter configura√ß√µes
                worldConfig = getWorldConfigFromUI();
                
                player.name = `Explorador${Math.floor(Math.random() * 1000)}`;
                document.getElementById('player-name-display').textContent = player.name;
                document.getElementById('player-info').style.display = 'block';

                // Gerar terreno com configura√ß√µes
                generateBrazilTerrain(worldConfig);
                createTerrain();
                
                // Posicionar jogador conforme escolha
                let startX, startY;
                const worldSize = mapSize * TILE_SIZE;
                
                switch(worldConfig.startRegion) {
                    case 'centro':
                        startX = worldSize * 0.5;
                        startY = worldSize * 0.55;
                        break;
                    case 'sudeste':
                        startX = worldSize * 0.75;
                        startY = worldSize * 0.6;
                        break;
                    case 'norte':
                        startX = worldSize * 0.5;
                        startY = worldSize * 0.3;
                        break;
                    case 'nordeste':
                        startX = worldSize * 0.8;
                        startY = worldSize * 0.45;
                        break;
                    case 'sul':
                        startX = worldSize * 0.4;
                        startY = worldSize * 0.8;
                        break;
                    case 'random':
                    default:
                        startX = worldSize * (0.3 + Math.random() * 0.4);
                        startY = worldSize * (0.3 + Math.random() * 0.4);
                        break;
                }
                
                player.x = startX;
                player.y = startY;
                player.z = (getHeightAt(player.x, player.y) || 0) + 5;
                
                inventory = { dirt: 0, sand: 0, rock: 0 };
                updateInventoryDisplay();
                
                saveGame(name);
                
                // Mensagens informativas
                addChatMessage("SISTEMA", "Bem-vindo ao Brasil Geogr√°fico Personalizado!");
                addChatMessage("SISTEMA", `Tamanho do mapa: ${mapSize}x${mapSize}`);
                addChatMessage("SISTEMA", `Inclina√ß√£o m√°xima: ${worldConfig.maxSlope} unidades`);
                addChatMessage("SISTEMA", `Regi√£o inicial: ${document.getElementById('start-region').selectedOptions[0].text}`);
                
                worldConfigModal.style.display = 'none';
                saveManager.style.display = 'none';
                closeMenu();
                document.getElementById('game-canvas').requestPointerLock();
            };

            btnSaveCurrent.onclick = function() {
                const name = document.getElementById('save-name-input').value.trim();
                if(!name) { 
                    alert("Digite um nome para o save."); 
                    return; 
                }
                saveGame(name);
            };
        }

        // --- Sistema de Save ---
        function getSaves() {
            const saves = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('animalysson_save_')) {
                    saves.push(key.replace('animalysson_save_', ''));
                }
            }
            return saves;
        }

        function saveGame(saveName) {
            const data = {
                heightMap, rockHeightMap, terrainTypeMap, compactionMap, biomeMap,
                player, inventory, mapSize, worldConfig,
                timestamp: Date.now()
            };
            try {
                localStorage.setItem('animalysson_save_' + saveName, JSON.stringify(data));
                addChatMessage("SISTEMA", `Jogo salvo: ${saveName}`);
                renderSaveList();
            } catch(e) {
                alert("Erro ao salvar. LocalStorage cheio?");
            }
        }

        window.loadGame = function(saveName) {
            const json = localStorage.getItem('animalysson_save_' + saveName);
            if (!json) return;
            const data = JSON.parse(json);
            
            heightMap = data.heightMap;
            rockHeightMap = data.rockHeightMap;
            terrainTypeMap = data.terrainTypeMap;
            compactionMap = data.compactionMap || [];
            biomeMap = data.biomeMap || [];
            player = data.player;
            document.getElementById('player-name-display').textContent = player.name;
            document.getElementById('player-info').style.display = 'block';
            inventory = data.inventory;
            mapSize = data.mapSize;
            worldConfig = data.worldConfig || worldConfig;
            
            createTerrain();
            updateInventoryDisplay();
            
            // Reset physics
            vx = 0; vz = 0; verticalVelocity = 0;
            
            addChatMessage("SISTEMA", `Jogo carregado: ${saveName}`);
            document.getElementById('save-manager').style.display = 'none';
            closeMenu();
            document.getElementById('game-canvas').requestPointerLock();
        };

        window.deleteSave = function(saveName) {
            if(confirm(`Excluir save '${saveName}'?`)) {
                localStorage.removeItem('animalysson_save_' + saveName);
                renderSaveList();
            }
        };

        window.renameSave = function(oldName) {
            const newName = prompt("Novo nome para o save:", oldName);
            if (newName && newName.trim() !== "" && newName !== oldName) {
                const oldKey = 'animalysson_save_' + oldName;
                const newKey = 'animalysson_save_' + newName.trim();
                
                if (localStorage.getItem(newKey)) {
                    alert("J√° existe um save com este nome!");
                    return;
                }
                
                const data = localStorage.getItem(oldKey);
                if (data) {
                    localStorage.setItem(newKey, data);
                    localStorage.removeItem(oldKey);
                    renderSaveList();
                }
            }
        };

        function renderSaveList() {
            const list = document.getElementById('save-list');
            list.innerHTML = '';
            const saves = getSaves();
            
            if (saves.length === 0) {
                list.innerHTML = '<div style="padding:10px; color:#666; text-align:center;">Nenhum save encontrado.</div>';
                return;
            }

            saves.forEach(name => {
                const item = document.createElement('div');
                item.className = 'save-item';
                item.innerHTML = `
                    <span class="save-name" onclick="document.getElementById('save-name-input').value = '${name}'" style="cursor:pointer;" title="Clique para selecionar">${name}</span>
                    <div class="save-actions">
                        <button class="btn-load" onclick="loadGame('${name}')">Carregar</button>
                        <button class="btn-rename" onclick="renameSave('${name}')">Renomear</button>
                        <button class="btn-delete" onclick="deleteSave('${name}')">Excluir</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        // --- Inicializa√ß√£o do Three.js ---
        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            scene.add(camera);

            const canvas = document.getElementById('game-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Luzes
            const aLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(aLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -200;
            directionalLight.shadow.camera.right = 200;
            directionalLight.shadow.camera.top = 200;
            directionalLight.shadow.camera.bottom = -200;
            scene.add(directionalLight);

            // Criar modelos das ferramentas
            createShovelModel();
            createPickaxeModel();
            createHandsModel();

            // √Ågua
            createWater();

            // Highlights para sele√ß√£o
            const highlightMat = new THREE.LineBasicMaterial({ color: 0xffffff, depthTest: false, transparent: true, opacity: 0.7 });
            const highlightGeo = new THREE.BufferGeometry();
            highlightGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(5 * 3), 3));
            selectionHighlight = new THREE.Line(highlightGeo, highlightMat);
            scene.add(selectionHighlight);
            selectionHighlight.visible = false;

            const adjBordersGeo = new THREE.BufferGeometry();
            adjBordersGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(24), 3));
            adjBordersGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(24), 3));
            adjacentBordersHighlight = new THREE.LineSegments(adjBordersGeo, new THREE.LineBasicMaterial({ 
                vertexColors: true, depthTest: false, transparent: true, opacity: 0.8 
            }));
            scene.add(adjacentBordersHighlight);
            adjacentBordersHighlight.visible = false;

            // Adjacent Tiles
            const adjTilesGeo = new THREE.BufferGeometry();
            adjTilesGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(64 * 3), 3));
            adjTilesGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(64 * 3), 3));
            adjacentTilesHighlight = new THREE.LineSegments(adjTilesGeo, new THREE.LineBasicMaterial({ 
                vertexColors: true, depthTest: false, transparent: true, opacity: 0.4 
            }));
            adjacentTilesHighlight.renderOrder = 997;
            scene.add(adjacentTilesHighlight);
            adjacentTilesHighlight.visible = false;

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onMouseWheel, { passive: false });
            
            // Limpa todas as teclas quando perde o foco
            window.addEventListener('blur', () => {
                keys = {};
                vx = 0;
                vz = 0;
            });

            animate();
            updateInventoryUI();
        }

        // --- Modelos 3D ---
        function createShovelModel() {
            shovelGroup = new THREE.Group();
            const metalColor = 0x6a94a2;
            const woodColor = 0x8b5a2b;
            const handleMat = new THREE.MeshLambertMaterial({ color: woodColor });
            const headMat = new THREE.MeshLambertMaterial({ color: metalColor });

            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.0, 8), handleMat);
            handle.rotation.z = Math.PI / 2;
            shovelGroup.add(handle);

            const shovelShape = new THREE.Shape();
            shovelShape.moveTo(0, -0.18);
            shovelShape.lineTo(0.25, -0.15);
            shovelShape.lineTo(0.35, 0);
            shovelShape.lineTo(0.25, 0.15);
            shovelShape.lineTo(0, 0.18);
            shovelShape.lineTo(0, -0.18);
            const head = new THREE.Mesh(new THREE.ExtrudeGeometry(shovelShape, { depth: 0.04, bevelEnabled: false }), headMat);
            head.position.set(0.45, -0.02, 0);
            head.rotation.x = Math.PI / 2;
            shovelGroup.add(head);

            shovelGroup.position.set(0.6, -0.7, -1.0);
            shovelGroup.rotation.y = -Math.PI / 3;
            shovelGroup.rotation.z = Math.PI / 8;
            camera.add(shovelGroup);
            shovelGroup.visible = false;
        }

        function createPickaxeModel() {
            pickaxeGroup = new THREE.Group();
            const metalColor = 0x555555;
            const woodColor = 0x8b5a2b;
            const handleMat = new THREE.MeshLambertMaterial({ color: woodColor });
            const headMat = new THREE.MeshLambertMaterial({ color: metalColor });

            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.0, 8), handleMat);
            handle.rotation.z = Math.PI / 2;
            pickaxeGroup.add(handle);

            const headGroup = new THREE.Group();
            headGroup.position.set(0.45, 0, 0);
            const center = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.07, 0.12), headMat);
            headGroup.add(center);

            const spikeGeo = new THREE.ConeGeometry(0.04, 0.35, 8);
            const spike1 = new THREE.Mesh(spikeGeo, headMat);
            spike1.position.set(0, 0, 0.2); spike1.rotation.x = Math.PI / 2;
            headGroup.add(spike1);

            const spike2 = new THREE.Mesh(spikeGeo, headMat);
            spike2.position.set(0, 0, -0.2); spike2.rotation.x = -Math.PI / 2;
            headGroup.add(spike2);
            pickaxeGroup.add(headGroup);

            pickaxeGroup.position.set(0.6, -0.7, -1.0);
            camera.add(pickaxeGroup);
            pickaxeGroup.visible = false;
        }

        function createHandsModel() {
            armsGroup = new THREE.Group();
            const skinColor = 0xe8beac;
            const sleeveColor = 0x2e4a39;
            const handMat = new THREE.MeshLambertMaterial({ color: skinColor });
            const sleeveMat = new THREE.MeshLambertMaterial({ color: sleeveColor });

            const rArm = new THREE.Group(); 
            rArm.name = "rightArm";
            rArm.add(new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.09, 0.6, 8), sleeveMat).rotateX(Math.PI/2));
            const rHand = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 0.18), handMat); 
            rHand.position.z = -0.35;
            rArm.add(rHand);
            rArm.position.set(0.3, -0.4, -0.5); 
            rArm.rotation.y = -0.1;
            armsGroup.add(rArm);

            const lArm = new THREE.Group(); 
            lArm.name = "leftArm";
            lArm.add(new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.09, 0.6, 8), sleeveMat).rotateX(Math.PI/2));
            const lHand = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 0.18), handMat); 
            lHand.position.z = -0.35;
            lArm.add(lHand);
            lArm.position.set(-0.3, -0.4, -0.5); 
            lArm.rotation.y = 0.1;
            armsGroup.add(lArm);

            camera.add(armsGroup);
            armsGroup.visible = false;
        }

        function updateInventoryUI() {
            for (let i = 0; i < 3; i++) {
                const slot = document.getElementById(`slot-${i}`);
                if (slot) {
                    if (i === selectedSlot) slot.classList.add('active');
                    else slot.classList.remove('active');
                }
            }

            if (shovelGroup && pickaxeGroup && armsGroup) {
                const rArm = armsGroup.getObjectByName("rightArm");
                const lArm = armsGroup.getObjectByName("leftArm");

                shovelGroup.visible = false;
                pickaxeGroup.visible = false;

                if (selectedSlot === 1 && isFirstPerson) {
                    shovelGroup.visible = true;
                    shovelGroup.position.set(0.1, -0.85, -0.7);
                    shovelGroup.rotation.set(0.2, Math.PI / 1.8, 0.4);
                    if (rArm) { 
                        rArm.position.set(0.35, -0.5, -0.4); 
                        rArm.rotation.set(-0.2, -0.4, 0.1); 
                    }
                    if (lArm) { 
                        lArm.position.set(-0.1, -0.55, -0.6); 
                        lArm.rotation.set(0.3, 0.6, -0.1); 
                    }
                } else if (selectedSlot === 2 && isFirstPerson) {
                    pickaxeGroup.visible = true;
                    pickaxeGroup.position.set(0.1, -0.85, -0.7);
                    pickaxeGroup.rotation.set(0.2, Math.PI / 1.8, 0.4);
                    if (rArm) { 
                        rArm.position.set(0.35, -0.5, -0.4); 
                        rArm.rotation.set(-0.2, -0.4, 0.1); 
                    }
                    if (lArm) { 
                        lArm.position.set(-0.1, -0.55, -0.6); 
                        lArm.rotation.set(0.3, 0.6, -0.1); 
                    }
                } else {
                    if (rArm) { 
                        rArm.position.set(0.3, -0.4, -0.5); 
                        rArm.rotation.set(0, -0.1, 0); 
                    }
                    if (lArm) { 
                        lArm.position.set(-0.3, -0.4, -0.5); 
                        lArm.rotation.set(0, 0.1, 0); 
                    }
                }
            }
        }

        // --- Terreno e √Ågua ---
        function createWater() {
            if (waterMesh) scene.remove(waterMesh);
            const geometry = new THREE.PlaneGeometry(mapSize * TILE_SIZE * 2, mapSize * TILE_SIZE * 2, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x006994,
                emissive: 0x001e33,
                specular: 0x111111,
                shininess: 50,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                flatShading: false
            });
            
            waterMesh = new THREE.Mesh(geometry, material);
            waterMesh.rotation.x = -Math.PI / 2;
            waterMesh.position.y = 1.5; // N√≠vel do mar
            waterMesh.position.x = (mapSize * TILE_SIZE) / 2;
            waterMesh.position.z = (mapSize * TILE_SIZE) / 2;
            
            scene.add(waterMesh);
        }

        function updateWater() {
            if (!waterMesh) return;
            // ALTERA√á√ÉO: Tempo mais lento (0.00075) e amplitude reduzida para 0.1
            const time = Date.now() * 0.00075; // Mais devagar
            const positions = waterMesh.geometry.attributes.position;
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                
                // ALTERA√á√ÉO: Altura de onda reduzida para 0.1 (bem suave)
                const z = Math.sin(x * 0.03 + time) * 0.1 + // Onda bem suave
                          Math.cos(y * 0.02 + time * 0.6) * 0.1; // Onda bem suave
                
                positions.setZ(i, z);
            }
            positions.needsUpdate = true;
            waterMesh.geometry.computeVertexNormals();
        }

        function createTerrain() {
            if (terrain) scene.remove(terrain);
            if (!heightMap || heightMap.length === 0) return;

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const indices = [];
            let vertexOffset = 0;

            for (let x = 0; x < mapSize - 1; x++) {
                for (let z = 0; z < mapSize - 1; z++) {
                    const h1 = heightMap[x][z] * METERS_PER_TERRA;
                    const h2 = heightMap[x + 1][z] * METERS_PER_TERRA;
                    const h3 = heightMap[x + 1][z + 1] * METERS_PER_TERRA;
                    const h4 = heightMap[x][z + 1] * METERS_PER_TERRA;

                    const type = terrainTypeMap[x][z];
                    const biome = biomeMap[x][z];
                    
                    // Cores baseadas no bioma e tipo de terreno
                    let color;
                    
                    if (type === 5) { // Rocha
                        color = { r: 0.5, g: 0.5, b: 0.5 };
                    } else if (type === 3) { // Areia
                        color = { r: 0.8, g: 0.75, b: 0.5 };
                    } else {
                        // Cores baseadas no bioma com suaviza√ß√£o
                        switch (biome) {
                            case BIOME_AMAZONIA:
                                color = { r: 0.1, g: 0.5, b: 0.1 }; // Verde escuro
                                if (type === 1) color = { r: 0.3, g: 0.4, b: 0.2 }; // Terra amaz√¥nica
                                break;
                                
                            case BIOME_CERRADO:
                                color = { r: 0.4, g: 0.5, b: 0.2 }; // Verde amarelado
                                if (type === 1) color = { r: 0.5, g: 0.4, b: 0.2 };
                                break;
                                
                            case BIOME_CAATINGA:
                                color = { r: 0.6, g: 0.5, b: 0.3 }; // Marrom claro
                                if (type === 2) color = { r: 0.5, g: 0.4, b: 0.2 };
                                break;
                                
                            case BIOME_MATA_ATLANTICA:
                                color = { r: 0.2, g: 0.6, b: 0.2 }; // Verde vibrante
                                break;
                                
                            case BIOME_PAMPA:
                                color = { r: 0.3, g: 0.6, b: 0.3 }; // Verde claro
                                break;
                                
                            case BIOME_PANTANAL:
                                color = { r: 0.2, g: 0.5, b: 0.4 }; // Verde-azulado
                                break;
                                
                            case BIOME_COSTEIRA:
                                color = { r: 0.7, g: 0.8, b: 0.5 }; // Areia/vegeta√ß√£o costeira
                                break;
                                
                            case BIOME_MONTANHA:
                                if (type === 4) {
                                    color = { r: 0.4, g: 0.35, b: 0.3 }; // Argila de montanha
                                } else {
                                    color = { r: 0.3, g: 0.5, b: 0.3 }; // Vegeta√ß√£o de montanha
                                }
                                break;
                                
                            default:
                                color = { r: 0.2, g: 0.6, b: 0.2 }; // Grama padr√£o
                                break;
                        }
                    }

                    vertices.push(x * TILE_SIZE, h1, z * TILE_SIZE);
                    vertices.push((x + 1) * TILE_SIZE, h2, z * TILE_SIZE);
                    vertices.push((x + 1) * TILE_SIZE, h3, (z + 1) * TILE_SIZE);
                    vertices.push(x * TILE_SIZE, h4, (z + 1) * TILE_SIZE);

                    for (let i = 0; i < 4; i++) colors.push(color.r, color.g, color.b);

                    indices.push(vertexOffset, vertexOffset + 2, vertexOffset + 1);
                    indices.push(vertexOffset, vertexOffset + 3, vertexOffset + 2);
                    vertexOffset += 4;
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const material = new THREE.MeshLambertMaterial({ vertexColors: true, side: THREE.DoubleSide });
            terrain = new THREE.Mesh(geometry, material);
            terrain.receiveShadow = true;
            scene.add(terrain);
        }

        // --- HUD e Interface ---
        function updateInventoryDisplay() {
            document.getElementById('inv-dirt').textContent = inventory.dirt;
            document.getElementById('inv-sand').textContent = inventory.sand;
            document.getElementById('inv-rock').textContent = inventory.rock;
        }

        // Atualizar indicador de inclina√ß√£o no HUD
        function updateSlopeIndicator(slope) {
            const indicator = document.getElementById('slope-indicator');
            const normalizedSlope = Math.abs(Math.round(slope));
            
            // Cor baseada na inclina√ß√£o
            let color = '#00ff00'; // Verde (baixa)
            if (normalizedSlope > CRITICAL_SLOPE) {
                color = '#ff0000'; // Vermelho (cr√≠tico)
            } else if (normalizedSlope > MAX_CLIMB_SLOPE) {
                color = '#ff9900'; // Laranja (alta)
            } else if (normalizedSlope > SLIP_START_SLOPE) {
                color = '#ffff00'; // Amarelo (m√©dia)
            }
            
            indicator.style.display = 'block';
            indicator.innerHTML = `<span style="color:${color}">Inclina√ß√£o: ${normalizedSlope} (${SLIP_START_SLOPE}/${MAX_CLIMB_SLOPE}/${CRITICAL_SLOPE})</span>`;
        }

        // --- Movimento e F√≠sica ---
        function updateCamera() {
            cameraYaw = targetYaw;
            cameraPitch = targetPitch;
            cameraDistance += (targetDistance - cameraDistance) * cameraSmoothness;

            if (isFirstPerson) {
                camera.position.set(player.x, player.z + cameraHeight, player.y);
                const lookX = player.x + Math.cos(cameraPitch) * Math.sin(cameraYaw);
                const lookY = player.z + cameraHeight + Math.sin(cameraPitch);
                const lookZ = player.y + Math.cos(cameraPitch) * Math.cos(cameraYaw);
                camera.lookAt(lookX, lookY, lookZ);
            } else {
                const targetX = player.x;
                const targetY = player.z + cameraHeight;
                const targetZ = player.y;
                const offsetX = cameraDistance * Math.sin(cameraYaw) * Math.cos(cameraPitch);
                const offsetY = cameraDistance * Math.sin(cameraPitch);
                const offsetZ = cameraDistance * Math.cos(cameraYaw) * Math.cos(cameraPitch);
                camera.position.set(targetX - offsetX, targetY + offsetY, targetZ - offsetZ);
                camera.lookAt(targetX, targetY, targetZ);
            }
        }

        function updatePlayerMovement() {
            const terrainHeight = getHeightAt(player.x, player.y);
            const isGrounded = player.z <= terrainHeight + 0.05;

            let inputX = 0, inputZ = 0;
            characterYaw = cameraYaw;
            const sin = Math.sin(characterYaw), cos = Math.cos(characterYaw);
            const forward = { x: sin, z: cos }, right = { x: cos, z: -sin };

            if (keys['w'] || keys['W']) { inputX += forward.x; inputZ += forward.z; }
            if (keys['s'] || keys['S']) { inputX -= forward.x; inputZ -= forward.z; }
            if (keys['a'] || keys['A']) { inputX += right.x; inputZ += right.z; }
            if (keys['d'] || keys['D']) { inputX -= right.x; inputZ -= right.z; }

            const len = Math.sqrt(inputX * inputX + inputZ * inputZ);
            if (len > 0) { inputX /= len; inputZ /= len; }

            const isSprinting = keys['Shift'];
            const currentAccel = isSprinting ? acceleration * 3 : acceleration;
            let slopeSpeedMult = 1.0;

            if (len > 0 && isGrounded) {
                const stepSize = 0.5;
                const hAhead = getHeightAt(player.x + inputX * stepSize, player.y + inputZ * stepSize);
                currentSlope = ((hAhead - terrainHeight) / METERS_PER_TERRA) * (TILE_SIZE / stepSize);
                
                // Atualizar indicador de inclina√ß√£o
                updateSlopeIndicator(currentSlope);
                
                // N√ÉO BLOQUEAR MOVIMENTO - permitir sempre alguma subida
                // Apenas reduzir velocidade gradualmente conforme a inclina√ß√£o aumenta
                if (currentSlope >= 0) {
                    // F√≥rmula mais suave: 100% em inclina√ß√£o 0, 30% em inclina√ß√£o 25, 0% em inclina√ß√£o 40+
                    slopeSpeedMult = Math.max(0.1, 1.0 - (currentSlope / 40));
                    terraformWarningShown = false;
                }
            } else {
                updateSlopeIndicator(0);
                terraformWarningShown = false;
            }

            const airControl = 0.4;
            const effectiveAccel = isGrounded ? currentAccel : currentAccel * airControl;

            if (len > 0) {
                vx += inputX * effectiveAccel * slopeSpeedMult;
                vz += inputZ * effectiveAccel * slopeSpeedMult;
            } else {
                // Desacelera√ß√£o suave quando n√£o h√° input
                const stopFriction = 0.88;
                vx *= stopFriction;
                vz *= stopFriction;
                
                if (Math.abs(vx) < 0.005) vx = 0;
                if (Math.abs(vz) < 0.005) vz = 0;
            }

            let currentFriction = isGrounded ? (len > 0 ? friction : 0.88) : 0.985;
            vx *= currentFriction;
            vz *= currentFriction;

            const worldSize = (mapSize - 1) * TILE_SIZE;

            const nextX = player.x + vx;
            if (nextX >= 0 && nextX < worldSize) {
                player.x = nextX;
            } else {
                vx = 0;
            }

            const nextZ = player.y + vz;
            if (nextZ >= 0 && nextZ < worldSize) {
                player.y = nextZ;
            } else {
                vz = 0;
            }

            const currentTerrainHeight = getHeightAt(player.x, player.y);
            
            // Calcular inclina√ß√£o do terreno onde o jogador est√° (para escorregamento)
            const checkRadius = 0.3;
            const hRight = getHeightAt(player.x + checkRadius, player.y);
            const hLeft = getHeightAt(player.x - checkRadius, player.y);
            const hForward = getHeightAt(player.x, player.y + checkRadius);
            const hBack = getHeightAt(player.x, player.y - checkRadius);
            
            // Calcular gradiente (dire√ß√£o e magnitude da inclina√ß√£o)
            const gradientX = (hLeft - hRight) / (checkRadius * 2);
            const gradientZ = (hBack - hForward) / (checkRadius * 2);
            const slopeMagnitude = Math.sqrt(gradientX * gradientX + gradientZ * gradientZ);
            
            // Converter para unidades de terra
            const standingSlope = (slopeMagnitude / METERS_PER_TERRA) * TILE_SIZE;
            
            if (player.z <= currentTerrainHeight) {
                player.z = currentTerrainHeight;
                verticalVelocity = 0;
                
                const currentTime = Date.now();
                
                // CALCULAR FOR√áA DE ESCORREGAMENTO E REDU√á√ÉO DO PULO (MODIFICADO)
                let slideForce = 0;
                let jumpMultiplier = 1.0; // Multiplicador para for√ßa do pulo
                let warningMessage = "";
                
                if (standingSlope > SLIP_START_SLOPE && standingSlope <= MAX_CLIMB_SLOPE) {
                    // Inclina√ß√£o 15-25: escorregamento crescente gradualmente (0.5 ‚Üí 1.0)
                    const progress = (standingSlope - SLIP_START_SLOPE) / (MAX_CLIMB_SLOPE - SLIP_START_SLOPE);
                    slideForce = 0.5 + (progress * 0.5); // 0.5 a 1.0
                    // MODIFICADO: Pulo reduz de 100% para 80% (1.0 ‚Üí 0.8)
                    jumpMultiplier = 1.0 - (progress * 0.2);
                    warningMessage = "Terreno inclinado - cuidado ao andar.";
                } else if (standingSlope > MAX_CLIMB_SLOPE && standingSlope <= CRITICAL_SLOPE) {
                    // Inclina√ß√£o 25-30: escorregamento forte (1.1 ‚Üí 2.0)
                    const progress = (standingSlope - MAX_CLIMB_SLOPE) / (CRITICAL_SLOPE - MAX_CLIMB_SLOPE);
                    slideForce = 1.1 + (progress * 0.9); // 1.1 a 2.0
                    // MODIFICADO: Pulo reduz de 80% para 10% (0.8 ‚Üí 0.1)
                    jumpMultiplier = 0.8 - (progress * 0.7);
                    warningMessage = "Inclina√ß√£o muito alta! Voc√™ est√° escorregando!";
                } else if (standingSlope > CRITICAL_SLOPE) {
                    // Acima de 30: escorregamento m√°ximo
                    slideForce = 2.0;
                    // MODIFICADO: Pulo m√≠nimo (10%)
                    jumpMultiplier = 0.1;
                    warningMessage = "Inclina√ß√£o extrema! Imposs√≠vel subir!";
                }
                
                // Aplicar for√ßa de escorregamento se necess√°rio
                if (slideForce > 0) {
                    // ESCORREGAMENTO NA DIRE√á√ÉO DA DESCIDA (lateral)
                    const slideX = gradientX * slideForce * 0.012; // Reduzido de 0.018 para 0.012
                    const slideZ = gradientZ * slideForce * 0.012;
                    
                    // Aplicar escorregamento (sempre oposto ao gradiente - dire√ß√£o da descida)
                    vx += slideX;
                    vz += slideZ;
                    
                    // Aviso (com cooldown)
                    if (warningMessage && currentTime - lastWarningTime > WARNING_COOLDOWN) {
                        addChatMessage("Aviso", warningMessage);
                        lastWarningTime = currentTime;
                    }
                }
                
                // Pulo com for√ßa reduzida gradualmente
                if (keys[' '] && player.z <= currentTerrainHeight + 0.5) {
                    const effectiveJumpForce = baseJumpForce * jumpMultiplier;
                    if (effectiveJumpForce > 0.05) { // Pelo menos um pulo m√≠nimo
                        verticalVelocity = effectiveJumpForce;
                    }
                }
            } else {
                verticalVelocity -= gravity;
            }
            
            player.z += verticalVelocity;

            if (player.z < currentTerrainHeight) {
                player.z = currentTerrainHeight;
                verticalVelocity = 0;
            }

            document.getElementById('position-display').textContent = `X: ${player.x.toFixed(1)}, Y: ${player.y.toFixed(1)}, Z: ${player.z.toFixed(1)}`;
        }

        function getHeightAt(x, z) {
            if (!heightMap || heightMap.length === 0) return 0;
            const gx = x / TILE_SIZE;
            const gz = z / TILE_SIZE;
            const ix = Math.floor(gx);
            const iz = Math.floor(gz);
            const fx = gx - ix;
            const fz = gz - iz;

            if (ix < 0 || ix >= mapSize - 1 || iz < 0 || iz >= mapSize - 1) return 0;

            const h00 = heightMap[ix][iz];
            const h10 = heightMap[ix + 1][iz];
            const h01 = heightMap[ix][iz + 1];
            const h11 = heightMap[ix + 1][iz + 1];

            const hX0 = h00 * (1 - fx) + h10 * fx;
            const hX1 = h01 * (1 - fx) + h11 * fx;
            return (hX0 * (1 - fz) + hX1 * fz) * METERS_PER_TERRA;
        }

        // --- Terraforma√ß√£o ---
        function applyTerraform(target, actionType) {
            const { x, y, mode } = target;
            const tx = x, ty = y;
            let droppedMaterialType = -1;

            if (mode === 'corner') {
                if (tx >= 0 && tx < mapSize && ty >= 0 && ty < mapSize) {
                    const currentH = heightMap[tx][ty];
                    const rockH = rockHeightMap[tx][ty];
                    let newH = currentH;

                    if (actionType === 'dig') {
                        if (currentH > rockH) {
                            newH = currentH - 1;
                            const currentType = terrainTypeMap[Math.min(tx, mapSize-2)][Math.min(ty, mapSize-2)];
                            if (currentType === 3) {
                                inventory.sand++;
                                addChatMessage("A√ß√£o", "Voc√™ cavou areia.");
                            } else {
                                inventory.dirt++;
                                addChatMessage("A√ß√£o", "Voc√™ cavou terra.");
                            }
                        } else {
                            addChatMessage("Aviso", "Voc√™ atingiu a rocha s√≥lida.");
                            return;
                        }
                    } else if (actionType === 'pack') {
                        newH = currentH + 1;
                        if (inventory.dirt > 0) {
                            inventory.dirt--;
                            droppedMaterialType = 1;
                            addChatMessage("A√ß√£o", "Voc√™ soltou terra no ch√£o.");
                        } else if (inventory.sand > 0) {
                            inventory.sand--;
                            droppedMaterialType = 3;
                            addChatMessage("A√ß√£o", "Voc√™ soltou areia no ch√£o.");
                        }
                    } else if (actionType === 'mine') {
                        if (currentH <= rockH) {
                            const neighbors = [[tx+1, ty], [tx-1, ty], [tx, ty+1], [tx, ty-1]];
                            let canMine = true;
                            for(let n of neighbors) {
                                if(n[0]>=0 && n[0]<mapSize && n[1]>=0 && n[1]<mapSize) {
                                    if (heightMap[n[0]][n[1]] > rockHeightMap[n[0]][n[1]]) {
                                        canMine = false; break;
                                    }
                                }
                            }
                            if (!canMine) {
                                addChatMessage("Erro", "Limpe a terra ao redor antes de minerar.");
                                return;
                            }
                            rockHeightMap[tx][ty] -= 1;
                            newH = currentH - 1;
                            inventory.rock++;
                            addChatMessage("A√ß√£o", "Voc√™ minerou fragmentos de pedra.");
                        }
                    }

                    // REMOVIDO: Verifica√ß√£o de inclina√ß√£o m√°xima para terraforma√ß√£o
                    // Agora voc√™ pode cavar em qualquer inclina√ß√£o!

                    heightMap[tx][ty] = newH;
                }
                
                // Atualizar tiles adjacentes
                const tilesToUpdate = [];
                if (x < mapSize - 1 && y < mapSize - 1) tilesToUpdate.push({ x, y });
                if (x > 0 && y < mapSize - 1) tilesToUpdate.push({ x: x - 1, y });
                if (x < mapSize - 1 && y > 0) tilesToUpdate.push({ x, y: y - 1 });
                if (x > 0 && y > 0) tilesToUpdate.push({ x: x - 1, y: y - 1 });

                tilesToUpdate.forEach(t => {
                    const prevType = terrainTypeMap[t.x][t.y];
                    const c1 = heightMap[t.x][t.y] === rockHeightMap[t.x][t.y];
                    const c2 = heightMap[t.x + 1][t.y] === rockHeightMap[t.x + 1][t.y];
                    const c3 = heightMap[t.x][t.y + 1] === rockHeightMap[t.x][t.y + 1];
                    const c4 = heightMap[t.x + 1][t.y + 1] === rockHeightMap[t.x + 1][t.y + 1];

                    let newType = prevType;
                    if (c1 && c2 && c3 && c4) newType = 5;
                    else {
                        if (actionType === 'pack' && droppedMaterialType !== -1) newType = droppedMaterialType;
                        else if (prevType === 0 && actionType === 'dig') newType = 1;
                        else if (prevType === 5 && actionType === 'pack') newType = droppedMaterialType;
                    }
                    terrainTypeMap[t.x][t.y] = newType;

                    if (newType === 1 || newType === 2) {
                        dirtTimestamps[`${t.x},${t.y}`] = Date.now();
                    }
                });
            }

            updateInventoryDisplay();
            createTerrain();
        }

        function startAction(name, duration, onComplete) {
            if (currentAction) return;

            currentAction = {
                name: name,
                startTime: Date.now(),
                duration: duration,
                onComplete: onComplete
            };

            document.getElementById('action-bar-container').style.display = 'block';
            document.getElementById('action-text').textContent = name;
        }

        function updateAction() {
            if (!currentAction) return;

            const elapsed = Date.now() - currentAction.startTime;
            const progress = Math.min(100, (elapsed / currentAction.duration) * 100);
            document.getElementById('action-bar-fill').style.width = progress + '%';

            if (elapsed >= currentAction.duration) {
                currentAction.onComplete();
                cancelAction();
            }
        }

        function cancelAction() {
            currentAction = null;
            document.getElementById('action-bar-container').style.display = 'none';
            document.getElementById('action-bar-fill').style.width = '0%';
        }

        function validateTerraform(target, actionType) {
            const { x, y } = target;
            if (x < 0 || x >= mapSize || y < 0 || y >= mapSize) return false;

            const currentH = heightMap[x][y];
            const rockH = rockHeightMap[x][y];
            let newH = currentH;

            if (actionType === 'dig') {
                if (currentH <= rockH) {
                    return false;
                }
                newH = currentH - 1;
            } else if (actionType === 'pack') {
                newH = currentH + 1;
            } else if (actionType === 'mine') {
                if (currentH > rockH) {
                    return false;
                }
                const neighbors = [[x+1, y], [x-1, y], [x, y+1], [x, y-1]];
                let canMine = true;
                for(let n of neighbors) {
                    if(n[0]>=0 && n[0]<mapSize && n[1]>=0 && n[1]<mapSize) {
                        if (heightMap[n[0]][n[1]] > rockHeightMap[n[0]][n[1]]) {
                            canMine = false; break;
                        }
                    }
                }
                if (!canMine) {
                    return false;
                }
                newH = currentH - 1;
            }

            // REMOVIDO: Verifica√ß√£o de inclina√ß√£o m√°xima para terraforma√ß√£o
            // Agora voc√™ pode cavar em qualquer inclina√ß√£o!

            return true;
        }

        function handleTerraforming() {
            if (!mouseDown.left && !mouseDown.right) {
                if (currentAction) cancelAction();
                return;
            }
            if (!terraformTarget.valid) return;
            if (currentAction) return;

            if (selectedSlot === 1) {
                if (mouseDown.left) {
                    if (validateTerraform(terraformTarget, 'dig')) {
                        startAction("Cavando...", 1000, () => applyTerraform(terraformTarget, 'dig'));
                    }
                } else if (mouseDown.right) {
                    if (inventory.dirt > 0 || inventory.sand > 0) {
                        if (validateTerraform(terraformTarget, 'pack')) {
                            startAction("Nivelando...", 1500, () => applyTerraform(terraformTarget, 'pack'));
                        }
                    } else {
                        addChatMessage("Invent√°rio", "Voc√™ precisa de terra ou areia.");
                    }
                }
            } else if (selectedSlot === 2) {
                if (mouseDown.left) {
                    if (validateTerraform(terraformTarget, 'mine')) {
                        startAction("Minerando...", 2000, () => applyTerraform(terraformTarget, 'mine'));
                    }
                }
            }
        }

        // --- Sele√ß√£o e Interface ---
        function updateSelectionCursor() {
            if (!selectionHighlight || !terrain || !heightMap) return;
            selectionHighlight.visible = false;
            terraformTarget.valid = false;
            if (adjacentBordersHighlight) adjacentBordersHighlight.visible = false;
            if (adjacentTilesHighlight) adjacentTilesHighlight.visible = false;
            hideCursorLabel();

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObject(terrain);

            if (intersects.length === 0 || intersects[0].distance > 12) return;

            const rx = Math.round(intersects[0].point.x / TILE_SIZE);
            const rz = Math.round(intersects[0].point.z / TILE_SIZE);

            if (rx >= 0 && rx < mapSize && rz >= 0 && rz < mapSize) {
                terraformTarget = { x: rx, y: rz, valid: true, mode: 'corner' };
                
                const h = heightMap[rx][rz];
                const cx = rx * TILE_SIZE;
                const cz = rz * TILE_SIZE;
                const ch = h * METERS_PER_TERRA + 0.05;

                if (selectedSlot === 1 || selectedSlot === 2) {
                    drawAdjacentBorders(rx, rz);
                    drawAdjacentTiles(rx, rz);
                }

                let labelText = `H: ${h}`;
                if (h <= rockHeightMap[rx][rz]) labelText += " (Rocha)";
                
                if (selectedSlot === 1) {
                    let maxS = 0;
                    const neighbors = [[rx+1, rz], [rx-1, rz], [rx, rz+1], [rx, rz-1]];
                    for(let n of neighbors) {
                        if(n[0]>=0 && n[0]<mapSize && n[1]>=0 && n[1]<mapSize) {
                            const diff = Math.abs(heightMap[n[0]][n[1]] - h);
                            if(diff > maxS) maxS = diff;
                        }
                    }
                    labelText += ` | Inclina√ß√£o: ${maxS}/${worldConfig.maxSlope}`;
                }

                showCustomLabel(cx, ch + 1, cz, labelText);
            }
        }

        function showCustomLabel(x, y, z, text, color = '#fff') {
            const el = document.getElementById('cursor-label');
            const screenPos = toScreenPosition(new THREE.Vector3(x, y, z));
            if (screenPos.visible) {
                el.style.display = 'block';
                el.style.left = screenPos.x + 'px';
                el.style.top = screenPos.y + 'px';
                el.textContent = text;
                el.style.color = color;
            } else {
                el.style.display = 'none';
            }
        }

        function hideCursorLabel() {
            document.getElementById('cursor-label').style.display = 'none';
        }

        function drawAdjacentBorders(cx, cz) {
            if (!adjacentBordersHighlight) return;
            const positions = adjacentBordersHighlight.geometry.attributes.position.array;
            const colors = adjacentBordersHighlight.geometry.attributes.color.array;
            let idx = 0, colorIdx = 0;
            const borders = [
                { x1: cx, z1: cz, x2: cx, z2: cz - 1 },
                { x1: cx, z1: cz, x2: cx, z2: cz + 1 },
                { x1: cx, z1: cz, x2: cx + 1, z2: cz },
                { x1: cx, z1: cz, x2: cx - 1, z2: cz }
            ];

            let r = 1, g = 1, b = 1;
            if (selectedSlot === 1) { r = 0; g = 1; b = 0; }
            else if (selectedSlot === 2) { r = 1; g = 0.5; b = 0; }

            borders.forEach(b => {
                if (b.x1 >= 0 && b.x1 < mapSize && b.z1 >= 0 && b.z1 < mapSize && b.x2 >= 0 && b.x2 < mapSize && b.z2 >= 0 && b.z2 < mapSize) {
                    const h1 = heightMap[b.x1][b.z1] * METERS_PER_TERRA + 0.05;
                    const h2 = heightMap[b.x2][b.z2] * METERS_PER_TERRA + 0.05;
                    const wx1 = b.x1 * TILE_SIZE, wz1 = b.z1 * TILE_SIZE;
                    const wx2 = b.x2 * TILE_SIZE, wz2 = b.z2 * TILE_SIZE;
                    
                    positions[idx++] = wx1; positions[idx++] = h1; positions[idx++] = wz1;
                    positions[idx++] = wx2; positions[idx++] = h2; positions[idx++] = wz2;
                    
                    for(let k=0; k<2; k++) { colors[colorIdx++] = r; colors[colorIdx++] = g; colors[colorIdx++] = b; }
                }
            });
            adjacentBordersHighlight.geometry.setDrawRange(0, idx / 3);
            adjacentBordersHighlight.geometry.attributes.position.needsUpdate = true;
            adjacentBordersHighlight.geometry.attributes.color.needsUpdate = true;
            adjacentBordersHighlight.visible = true;
        }

        function drawAdjacentTiles(cx, cz) {
            if (!adjacentTilesHighlight) return;
            const positions = adjacentTilesHighlight.geometry.attributes.position.array;
            const colors = adjacentTilesHighlight.geometry.attributes.color.array;
            let idx = 0, colorIdx = 0;

            const tiles = [
                { x: cx - 1, y: cz - 1 },
                { x: cx, y: cz - 1 },
                { x: cx - 1, y: cz },
                { x: cx, y: cz }
            ];

            let r = 0.5, g = 0.5, b = 0.5;
            if (selectedSlot === 1) { r = 0; g = 0.5; b = 0; }
            else if (selectedSlot === 2) { r = 0.5; g = 0.2; b = 0; }

            tiles.forEach(t => {
                if (t.x >= 0 && t.x < mapSize - 1 && t.y >= 0 && t.y < mapSize - 1) {
                    const h00 = heightMap[t.x][t.y] * METERS_PER_TERRA + 0.05;
                    const h10 = heightMap[t.x + 1][t.y] * METERS_PER_TERRA + 0.05;
                    const h11 = heightMap[t.x + 1][t.y + 1] * METERS_PER_TERRA + 0.05;
                    const h01 = heightMap[t.x][t.y + 1] * METERS_PER_TERRA + 0.05;

                    const addLine = (x1, y1, z1, x2, y2, z2) => {
                        positions[idx++] = x1 * TILE_SIZE; positions[idx++] = y1; positions[idx++] = z1 * TILE_SIZE;
                        positions[idx++] = x2 * TILE_SIZE; positions[idx++] = y2; positions[idx++] = z2 * TILE_SIZE;
                        for(let k=0; k<2; k++) { colors[colorIdx++] = r; colors[colorIdx++] = g; colors[colorIdx++] = b; }
                    };

                    addLine(t.x, h00, t.y, t.x + 1, h10, t.y);
                    addLine(t.x + 1, h10, t.y, t.x + 1, h11, t.y + 1);
                    addLine(t.x + 1, h11, t.y + 1, t.x, h01, t.y + 1);
                    addLine(t.x, h01, t.y + 1, t.x, h00, t.y);
                }
            });

            adjacentTilesHighlight.geometry.setDrawRange(0, idx / 3);
            adjacentTilesHighlight.geometry.attributes.position.needsUpdate = true;
            adjacentTilesHighlight.geometry.attributes.color.needsUpdate = true;
            adjacentTilesHighlight.visible = true;
        }

        function toScreenPosition(vector) {
            const v = vector.clone();
            v.project(camera);
            const widthHalf = window.innerWidth / 2;
            const heightHalf = window.innerHeight / 2;
            return {
                x: (v.x * widthHalf) + widthHalf,
                y: -(v.y * heightHalf) + heightHalf,
                visible: v.z < 1
            };
        }

        // Fun√ß√£o para obter o nome da regi√£o/subregi√£o
        function getRegionName(tx, ty) {
            const nx = tx / mapSize;
            const ny = ty / mapSize;
            const regionInfo = getBrazilRegionAndBiome(nx, ny);
            
            const subregionNames = {
                'RIO_AMAZONAS': 'Vale do Rio Amazonas',
                'PLANALTO_GUIANAS': 'Planalto das Guianas',
                'FLORESTA_AMAZONICA': 'Floresta Amaz√¥nica',
                'LITORAL': 'Litoral Nordestino',
                'CHAPADA_DIAMANTINA': 'Chapada Diamantina',
                'SERTAO': 'Sert√£o Nordestino',
                'PANTANAL': 'Pantanal',
                'CHAPADA_VEADEIROS': 'Chapada dos Veadeiros',
                'CERRADO': 'Cerrado',
                'SERRA_DO_MAR': 'Serra do Mar',
                'SERRA_MANTIQUEIRA': 'Serra da Mantiqueira',
                'PLANALTO_ATLANTICO': 'Planalto Atl√¢ntico',
                'SERRA_GERAL': 'Serra Geral',
                'PAMPA': 'Pampa',
                'PLANALTO_MERIDIONAL': 'Planalto Meridional',
                'ATLANTICO': 'Oceano Atl√¢ntico'
            };
            
            const regionNames = {
                'NORTE': 'Regi√£o Norte',
                'NORDESTE': 'Regi√£o Nordeste',
                'CENTRO_OESTE': 'Regi√£o Centro-Oeste',
                'SUDESTE': 'Regi√£o Sudeste',
                'SUL': 'Regi√£o Sul',
                'OCEANO': 'Oceano Atl√¢ntico'
            };
            
            return `${regionNames[regionInfo.region]} - ${subregionNames[regionInfo.subregion]}`;
        }

        // --- Chat e Mensagens ---
        function addChatMessage(name, msg) {
            const chatMessages = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = 'chat-message';
            div.innerHTML = `<strong>${name}:</strong> ${msg}`;
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function openChat() {
            chatOpen = true; keys = {};
            vx = 0; vz = 0; // Para o movimento completamente
            document.getElementById('chat-input-container').style.display = 'flex';
            document.getElementById('chat-input').focus();
            document.body.style.cursor = 'default';
        }

        function closeChat() {
            chatOpen = false;
            document.getElementById('chat-input-container').style.display = 'none';
            document.getElementById('chat-input').value = '';
            document.body.style.cursor = 'default';
            document.getElementById('game-canvas').requestPointerLock();
        }

        document.getElementById('chat-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const msg = e.target.value.trim();
                if (msg) addChatMessage(player.name, msg);
                closeChat();
            }
        });

        // --- Menu ---
        function openMenu() {
            menuOpen = true; keys = {};
            vx = 0; vz = 0; // Para o movimento completamente
            document.getElementById('menu').style.display = 'flex';
            document.body.style.cursor = 'default';
            document.exitPointerLock();
        }

        function closeMenu() {
            menuOpen = false;
            document.getElementById('menu').style.display = 'none';
        }

        function initPointerLock() {
            const canvas = document.getElementById('game-canvas');
            canvas.addEventListener('click', () => {
                if (!chatOpen && !menuOpen) canvas.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    closeMenu();
                } else {
                    if (!chatOpen) openMenu();
                }
            });
        }
        initPointerLock();

        // --- Event Handlers ---
        function onKeyDown(e) {
            if (e.key === 'Escape') {
                if (chatOpen) closeChat();
                else if (menuOpen) { 
                    document.getElementById('game-canvas').requestPointerLock(); 
                    closeMenu(); 
                }
                return;
            }
            if (chatOpen) return;
            keys[e.key] = true;
            if (e.key === 'Enter') { 
                e.preventDefault(); 
                openChat(); 
            }
        }

        function onKeyUp(e) { 
            const key = e.key.toLowerCase(); // Normaliza para min√∫scula
            keys[e.key] = false;
            
            // For√ßa reset se for tecla de movimento
            if (key === 'w' || key === 's' || key === 'a' || key === 'd') {
                
                // Limpa ambas vers√µes (mai√∫scula e min√∫scula)
                if (key === 'w') { keys['w'] = false; keys['W'] = false; }
                if (key === 's') { keys['s'] = false; keys['S'] = false; }
                if (key === 'a') { keys['a'] = false; keys['A'] = false; }
                if (key === 'd') { keys['d'] = false; keys['D'] = false; }
            }
        }

        function onMouseDown(e) { 
            if (e.button === 0) mouseDown.left = true; 
            if (e.button === 2) mouseDown.right = true; 
        }

        function onMouseUp(e) { 
            if (e.button === 0) mouseDown.left = false; 
            if (e.button === 2) mouseDown.right = false; 
        }
        
        function onMouseMove(e) {
            if (chatOpen || menuOpen || !document.pointerLockElement) return;
            const sens = 0.0015;
            targetYaw -= e.movementX * sens;
            targetPitch -= e.movementY * sens;
            targetPitch = Math.max(minPitch, Math.min(maxPitch, targetPitch));
        }

        function onMouseWheel(e) {
            if (menuOpen || chatOpen) return;
            if (e.deltaY > 0) selectedSlot = (selectedSlot + 1) % 3;
            else selectedSlot = (selectedSlot - 1 + 3) % 3;
            updateInventoryUI();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        document.addEventListener('contextmenu', e => e.preventDefault());

        // --- Loop Principal ---
        function animate() {
            requestAnimationFrame(animate);
            
            if (!chatOpen && !menuOpen) {
                updatePlayerMovement();
                updateSelectionCursor();
                handleTerraforming();
                updateAction();
                updateInventoryDisplay();
                updateTileInfo();
                updateWater();
            }
            
            updateCamera();
            
            // Anima√ß√£o das ferramentas (bob)
            if (isFirstPerson && (armsGroup || shovelGroup)) {
                const time = Date.now() * 0.005;
                const currentSpeed = Math.sqrt(vx * vx + vz * vz);
                const bobIntensity = currentSpeed > 0.1 ? Math.min(currentSpeed * 0.05, 0.03) : 0.005;
                const bobFreq = currentSpeed > 0.1 ? 2 : 1;
                const bobY = Math.sin(time * bobFreq) * bobIntensity;
                const bobX = Math.cos(time * bobFreq * 0.5) * bobIntensity * 0.5;

                if (armsGroup) {
                    armsGroup.position.y += ((0 + bobY) - armsGroup.position.y) * 0.1;
                    armsGroup.position.x += (bobX - armsGroup.position.x) * 0.1;
                }
                if (shovelGroup && selectedSlot === 1) {
                    shovelGroup.position.y += ((-0.85 + bobY) - shovelGroup.position.y) * 0.1;
                    shovelGroup.position.x += ((0.1 + bobX) - shovelGroup.position.x) * 0.1;
                }
                if (pickaxeGroup && selectedSlot === 2) {
                    pickaxeGroup.position.y += ((-0.85 + bobY) - pickaxeGroup.position.y) * 0.1;
                    pickaxeGroup.position.x += ((0.1 + bobX) - pickaxeGroup.position.x) * 0.1;
                }
            }

            renderer.render(scene, camera);
        }

        function updateTileInfo() {
            if (!terrain) return;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObject(terrain);
            const tileInfo = document.getElementById('tile-info');

            if (intersects.length > 0) {
                const p = intersects[0].point;
                const tx = Math.floor(p.x / TILE_SIZE);
                const ty = Math.floor(p.z / TILE_SIZE);

                if (tx >= 0 && tx < mapSize - 1 && ty >= 0 && ty < mapSize - 1) {
                    const type = terrainTypeMap[tx][ty];
                    let name = "Desconhecido";
                    if (type === 0) name = "Grama";
                    else if (type === 1) name = "Terra";
                    else if (type === 2) name = "Terra Compactada";
                    else if (type === 3) name = "Areia";
                    else if (type === 4) name = "Argila";
                    else if (type === 5) name = "Rocha";
                    
                    // Obter informa√ß√µes geogr√°ficas
                    const regionName = getRegionName(tx, ty);
                    
                    tileInfo.textContent = `Olhando: ${name} [${tx}, ${ty}] - ${regionName}`;
                    return;
                }
            }
            tileInfo.textContent = "Olhando: -";
        }

        // Timer de reflorestamento
        setInterval(() => {
            if (!worldConfig.autoReforestation) return;
            
            const now = Date.now();
            let updated = false;
            for (let x = 0; x < mapSize - 1; x++) {
                for (let y = 0; y < mapSize - 1; y++) {
                    if (terrainTypeMap[x] && terrainTypeMap[x][y] === 1) {
                        const key = `${x},${y}`;
                        const timestamp = dirtTimestamps[key] || 0;
                        const baseWaitTime = 60000;
                        const totalWaitTime = baseWaitTime + (compactionMap[x][y] || 0);

                        if (now - timestamp >= totalWaitTime) {
                            let hasAdjacentGrass = false;
                            const neighbors = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]];
                            for (const [nx, ny] of neighbors) {
                                if (nx < 0 || nx >= mapSize - 1 || ny < 0 || ny >= mapSize - 1) {
                                    hasAdjacentGrass = true; break;
                                } else if (terrainTypeMap[nx][ny] === 0) {
                                    hasAdjacentGrass = true; break;
                                }
                            }

                            if (hasAdjacentGrass) {
                                terrainTypeMap[x][y] = 0;
                                delete dirtTimestamps[key];
                                compactionMap[x][y] = 0;
                                updated = true;
                            }
                        }
                    }
                }
            }
            if (updated && typeof createTerrain === 'function') createTerrain();
        }, 5000);

    </script>
</body>
</html>
