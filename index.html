<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animalysson.io - Sistema de √Årvores</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            user-select: none;
        }

        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 3px black, 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: none;
            z-index: 102;
        }

        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 1000;
            max-width: 300px;
            pointer-events: none;
        }

        #player-info {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        #tile-info {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            color: #ffd700;
        }

        #player-name-display {
            font-size: 18px;
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }

        #controls-info {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            line-height: 1.6;
        }

        #slope-indicator {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            display: none;
            position: fixed;
            z-index: 1001;
            top: 150px;
            left: 20px;
            max-width: 300px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #chat-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 400px;
            z-index: 10;
        }

        #chat-messages {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: white;
        }

        .chat-message {
            margin-bottom: 5px;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .chat-message strong {
            color: #667eea;
        }

        #chat-input-container {
            display: flex;
        }

        #chat-input {
            flex: 1;
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 14px;
        }

        #chat-input:focus {
            outline: none;
            border-color: #764ba2;
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .menu-box {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: menuSlideIn 0.3s ease-out;
        }

        @keyframes menuSlideIn {
            from { opacity: 0; transform: scale(0.9) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .menu-box h2 {
            margin-bottom: 30px;
            color: #667eea;
            font-size: 2em;
        }

        .menu-box button {
            display: block;
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            font-size: 1.1em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .menu-box button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        #btn-exit {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
        }

        #chat-messages::-webkit-scrollbar { width: 6px; }
        #chat-messages::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); border-radius: 10px; }
        #chat-messages::-webkit-scrollbar-thumb { background: #667eea; border-radius: 10px; }
        #chat-messages::-webkit-scrollbar-thumb:hover { background: #764ba2; }

        #hotbar-container {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .hotbar-slot {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            opacity: 0.6;
        }

        .hotbar-slot.active {
            opacity: 1;
            background: rgba(255, 255, 255, 0.15);
            border-color: #4facfe;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.4);
            transform: scale(1.1) translateY(-5px);
        }

        .hotbar-slot.active::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background: #4facfe;
            border-radius: 50%;
            box-shadow: 0 0 10px #4facfe;
        }

        .world-label {
            position: absolute;
            font-family: 'Verdana', sans-serif;
            font-weight: bold;
            color: #55f;
            text-shadow: 1px 0px 0px #000, -1px 0px 0px #000, 0px 1px 0px #000, 0px -1px 0px #000;
            font-size: 16px;
            transform: translate(-50%, -50%);
            display: none;
            pointer-events: none;
        }

        #action-bar-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #555;
            border-radius: 10px;
            display: none;
            z-index: 90;
        }
        #action-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            width: 0%;
            border-radius: 10px;
            transition: width 0.1s linear;
        }
        #inventory-display { 
            position: fixed; 
            bottom: 40px; 
            right: 20px; 
            color: white; 
            text-align: right; 
            font-family: monospace; 
            text-shadow: 1px 1px 0 #000; 
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
        }

        #save-manager {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            backdrop-filter: blur(5px);
        }
        .save-list-container {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 10px;
            background: #f9f9f9;
        }
        .save-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #ddd;
            background: white;
            margin-bottom: 5px;
            border-radius: 4px;
        }
        .save-name { 
            font-weight: bold; 
            color: #333; 
            text-align: left; 
            cursor: pointer;
        }
        .save-name:hover {
            color: #667eea;
        }
        .save-actions button {
            width: auto;
            padding: 5px 10px;
            margin-left: 5px;
            font-size: 0.8em;
            display: inline-block;
            margin-bottom: 0;
        }
        .btn-load { 
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%) !important; 
            color: #000 !important; 
        }
        .btn-delete { 
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%) !important; 
        }
        .btn-rename { 
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%) !important; 
            color: #333 !important; 
        }
        
        #world-config-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            backdrop-filter: blur(10px);
        }

        .config-box {
            background: white;
            padding: 40px;
            border-radius: 20px;
            width: 600px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: menuSlideIn 0.3s ease-out;
        }

        .config-box h2 {
            margin-bottom: 25px;
            color: #667eea;
            font-size: 2em;
            text-align: center;
        }

        .config-section {
            margin-bottom: 25px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .config-section h3 {
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .config-group {
            margin-bottom: 15px;
        }

        .config-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #444;
        }

        .config-value {
            float: right;
            color: #667eea;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 10px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            vertical-align: middle;
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            margin-top: 5px;
        }

        .config-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }

        .config-buttons button {
            flex: 1;
            padding: 15px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        #btn-generate-world {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: #000;
        }

        #btn-cancel-config {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .preview-image {
            width: 100%;
            height: 150px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 10px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.2em;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .biome-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        .biome-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .biome-label {
            font-size: 12px;
            color: #666;
            margin-left: 5px;
        }

        .biome-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        #debug-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: lime;
            background: rgba(0,0,0,0.8);
            padding: 5px;
            pointer-events: none;
            white-space: pre;
            font-family: monospace;
            z-index: 9999;
            display:none;
        }

        .grid-label {
            position: absolute;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            font-weight: bold;
            color: #00a2ff;
            text-shadow: 1px 0px 0px #000, -1px 0px 0px #000, 0px 1px 0px #000, 0px -1px 0px #000;
            white-space: nowrap;
            transform: translate(-50%, -50%);
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 1px 3px;
            border-radius: 2px;
            display: none;
        }

        .edge-label {
            color: #ff9900;
            font-size: 9px;
        }

        .vertex-label {
            color: #00a2ff;
            font-size: 10px;
        }

        .tree-highlight {
            position: absolute;
            background: rgba(0, 255, 0, 0.3);
            border: 2px solid #00ff00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 99;
            display: none;
        }

        #tree-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            color: #00ff00;
            position: fixed;
            top: 120px;
            left: 20px;
            max-width: 300px;
            display: none;
            z-index: 1001;
        }

        #seedling-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            color: #98fb98;
            position: fixed;
            top: 160px;
            left: 20px;
            max-width: 300px;
            display: none;
            z-index: 1001;
        }

        .hotbar-slot.tree {
            background: rgba(0, 100, 0, 0.2);
            border-color: #00cc00;
        }

        .hotbar-slot.seeds {
            background: rgba(139, 69, 19, 0.2);
            border-color: #8b4513;
        }

        .growth-stage {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .growth-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ff9900);
            width: 0%;
            transition: width 0.3s;
            border-radius: 3px;
        }

        #tree-inventory-display {
            position: fixed;
            bottom: 40px;
            left: 20px;
            color: white;
            text-align: left;
            font-family: monospace;
            text-shadow: 1px 1px 0 #000;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            z-index: 100;
        }

        .tree-sapling {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .falling-leaves {
            position: absolute;
            pointer-events: none;
            z-index: 90;
        }

        .leaf-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00aa00;
            border-radius: 50%;
            opacity: 0.8;
            animation: leaf-fall linear forwards;
        }

        @keyframes leaf-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 0.8;
            }
            100% {
                transform: translateY(100px) rotate(720deg);
                opacity: 0;
            }
        }

        .tree-health-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 2px;
            margin-top: 3px;
            overflow: hidden;
        }

        .tree-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            width: 100%;
            border-radius: 2px;
            transition: width 0.3s;
        }

        @media (max-width: 768px) {
            #hud {
                max-width: 250px;
                font-size: 12px;
                top: 10px;
                left: 10px;
            }
            
            #hotbar-container {
                top: 80px;
                right: 10px;
                transform: scale(0.9);
            }
            
            #chat-container {
                width: 300px;
                bottom: 10px;
                left: 10px;
            }
            
            #inventory-display {
                bottom: 10px;
                right: 10px;
                font-size: 12px;
                padding: 8px;
            }
            
            .config-box {
                padding: 20px;
                width: 95%;
            }
            
            #slope-indicator {
                left: 10px;
                top: 120px;
                max-width: 250px;
                font-size: 12px;
                padding: 8px 12px;
            }
            
            .grid-label {
                font-size: 8px;
                padding: 0px 2px;
            }
            
            #tree-inventory-display {
                bottom: 10px;
                left: 10px;
                font-size: 12px;
                padding: 8px;
            }
            
            #tree-info, #seedling-info {
                left: 10px;
                max-width: 250px;
                font-size: 12px;
                padding: 8px 12px;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <div id="hud">
            <div id="player-info" style="display: none;">
                <span id="player-name-display"></span>
                <span id="position-display">X: 0, Y: 0, Z: 0</span>
            </div>
            <div id="tile-info">Olhando: -</div>
            <div id="tree-info"></div>
            <div id="seedling-info"></div>
            
            <div id="controls-info" style="display: block;">
                <strong>Controles:</strong><br>
                WASD - Mover | Shift - Correr | Espa√ßo - Pular<br>
                <span style="color: #ffd700;">üñ±Ô∏è Mouse - Olhar/Mirar</span><br>
                Clique Esq/Dir - Terraformar/Interagir | ENTER - Chat | ESC - Menu<br>
                <span style="color: #4facfe;">Roda do Mouse - Trocar ferramentas</span><br>
                <span style="color: #00ff00;">üå≥ Sistema de √Årvores Completo</span>
            </div>

            <div id="world-labels" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 1000;">
                <div id="cursor-label" class="world-label" style="color: #ffff00; font-size: 16px; font-weight: bold; text-shadow: 1px 1px 2px black;"></div>
            </div>

            <div id="action-bar-container"><div id="action-bar-fill"></div><div style="position:absolute; width:100%; text-align:center; top:-25px; color:white; font-weight:bold; text-shadow:1px 1px 0 #000;" id="action-text">A√ß√£o</div></div>
            
            <div id="inventory-display">
                <div>Terra: <span id="inv-dirt">0</span></div>
                <div>Areia: <span id="inv-sand">0</span></div>
                <div>Pedras: <span id="inv-rock">0</span></div>
            </div>
            
            <div id="tree-inventory-display">
                <div>Madeira: <span id="inv-wood">0</span></div>
                <div>Sementes: <span id="inv-seeds">0</span></div>
                <div>Mudas: <span id="inv-saplings">0</span></div>
            </div>
        </div>

        <div id="slope-indicator">Inclina√ß√£o: 0/20</div>

        <div id="chat-container">
            <div id="chat-messages"></div>
            <div id="chat-input-container" style="display: none;">
                <input type="text" id="chat-input" placeholder="Digite sua mensagem...">
            </div>
        </div>

        <div id="hotbar-container">
            <div class="hotbar-slot active" id="slot-0" title="M√£os vazias">
                <span class="slot-icon">‚úã</span>
            </div>
            <div class="hotbar-slot" id="slot-1" title="P√°">
                <span class="slot-icon">ü•Ñ</span>
            </div>
            <div class="hotbar-slot" id="slot-2" title="Picareta">
                <span class="slot-icon">‚õèÔ∏è</span>
            </div>
            <div class="hotbar-slot" id="slot-3" title="Machado">
                <span class="slot-icon">ü™ì</span>
            </div>
            <div class="hotbar-slot seeds" id="slot-4" title="Plantar √Årvores">
                <span class="slot-icon">üå±</span>
            </div>
            <div class="hotbar-slot tree" id="slot-5" title="Coletor de Sementes">
                <span class="slot-icon">üå∞</span>
            </div>
        </div>

        <div id="menu" style="display: none;">
            <div class="menu-box">
                <h2>Menu</h2>
                <button id="resume-btn">Continuar</button>
                <button id="fullscreen-btn">Tela Cheia</button>
                <button id="open-saves-btn">Gerenciar Saves</button>
                <button id="btn-exit">Sair</button>
            </div>
        </div>

        <div id="world-config-modal">
            <div class="config-box">
                <h2>Configura√ß√µes do Mundo</h2>
                
                <div class="preview-image" id="world-preview">
                    Gerando visualiza√ß√£o...
                </div>
                
                <div class="config-section">
                    <h3>‚öôÔ∏è Configura√ß√µes Gerais</h3>
                    <div class="config-group">
                        <label class="config-label">
                            Tamanho do Mapa: <span class="config-value" id="map-size-value">200</span>
                        </label>
                        <input type="range" id="map-size-slider" min="100" max="400" step="20" value="200">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Pequeno</span>
                            <span style="float:right">Grande</span>
                        </div>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Intensidade do Relevo: <span class="config-value" id="relief-value">50%</span>
                        </label>
                        <input type="range" id="relief-slider" min="10" max="100" value="50">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Plano</span>
                            <span style="float:right">Montanhoso</span>
                        </div>
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>üèîÔ∏è Controle de Terreno</h3>
                    <div class="config-group">
                        <label class="config-label">
                            Suaviza√ß√£o do Mapa: <span class="config-value" id="smooth-value">3</span>
                        </label>
                        <input type="range" id="smooth-slider" min="1" max="10" value="3">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Rugoso</span>
                            <span style="float:right">Suave</span>
                        </div>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Inclina√ß√£o M√°xima: <span class="config-value" id="slope-value">20</span>
                        </label>
                        <input type="range" id="slope-slider" min="5" max="40" value="20">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Suave</span>
                            <span style="float:right">√çngreme</span>
                        </div>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Transi√ß√£o entre Biomas: <span class="config-value" id="blend-value">3</span>
                        </label>
                        <input type="range" id="blend-slider" min="1" max="10" value="3">
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                            <span>Definida</span>
                            <span style="float:right">Suave</span>
                        </div>
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>üåé Recursos Naturais</h3>
                    <div class="config-group">
                        <label class="config-label">
                            <input type="checkbox" id="rivers-checkbox" checked> Gerar Rios
                        </label>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            <input type="checkbox" id="ocean-checkbox" checked> Incluir Oceano
                        </label>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Densidade de Vegeta√ß√£o: <span class="config-value" id="veg-value">70%</span>
                        </label>
                        <input type="range" id="veg-slider" min="0" max="100" value="70">
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>üå≥ Sistema de √Årvores</h3>
                    <div class="config-group">
                        <label class="config-label">
                            Densidade de √Årvores: <span class="config-value" id="tree-density-value">10%</span>
                        </label>
                        <input type="range" id="tree-density-slider" min="10" max="100" value="10">
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Crescimento Autom√°tico: <span class="config-value" id="auto-growth-value">Sim</span>
                        </label>
                        <input type="checkbox" id="auto-growth-checkbox" checked>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            Tempo de Crescimento: <span class="config-value" id="growth-time-value">120s</span>
                        </label>
                        <input type="range" id="growth-time-slider" min="30" max="300" step="30" value="120">
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            <input type="checkbox" id="seasonal-effects-checkbox" checked> Efeitos Sazonais
                        </label>
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>üéÆ Configura√ß√µes de Jogo</h3>
                    <div class="config-group">
                        <label class="config-label">
                            Ponto de In√≠cio:
                            <select id="start-region">
                                <option value="random">Aleat√≥rio</option>
                                <option value="centro">Centro-Oeste (Bras√≠lia)</option>
                                <option value="sudeste">Sudeste (S√£o Paulo)</option>
                                <option value="norte">Norte (Amaz√¥nia)</option>
                                <option value="nordeste">Nordeste (Bahia)</option>
                                <option value="sul">Sul (Rio Grande do Sul)</option>
                            </select>
                        </label>
                    </div>
                    
                    <div class="config-group">
                        <label class="config-label">
                            <input type="checkbox" id="reforestation-checkbox" checked> Reflorestamento Autom√°tico
                        </label>
                    </div>
                </div>
                
                <div class="biome-preview">
                    <div class="biome-item">
                        <div class="biome-color" style="background: #0a5"></div>
                        <span class="biome-label">Amaz√¥nia</span>
                    </div>
                    <div class="biome-item">
                        <div class="biome-color" style="background: #da5"></div>
                        <span class="biome-label">Cerrado</span>
                    </div>
                    <div class="biome-item">
                        <div class="biome-color" style="background: #b85"></div>
                        <span class="biome-label">Caatinga</span>
                    </div>
                    <div class="biome-item">
                        <div class="biome-color" style="background: #0c5"></div>
                        <span class="biome-label">Mata Atl√¢ntica</span>
                    </div>
                    <div class="biome-item">
                        <div class="biome-color" style="background: #0af"></div>
                        <span class="biome-label">Oceano</span>
                    </div>
                </div>
                
                <div class="config-buttons">
                    <button id="btn-cancel-config">Cancelar</button>
                    <button id="btn-generate-world">Gerar Mundo</button>
                </div>
            </div>
        </div>

        <div id="save-manager" style="display: none;">
            <div class="menu-box" style="width: 500px; max-width: 90%;">
                <h2>Saves</h2>
                <div id="save-list" class="save-list-container"></div>
                
                <div style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 10px;">
                    <h3>Novo Jogo / Salvar</h3>
                    <div style="display: flex; gap: 5px; justify-content: center; margin-bottom: 10px;">
                        <input type="text" id="save-name-input" placeholder="Nome do Save" style="padding: 8px; border-radius: 5px; border: 1px solid #ccc; flex: 1;">
                    </div>
                    <div style="display: flex; gap: 5px; justify-content: center;">
                        <button id="btn-open-world-config" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); font-size: 0.9em;">Novo Mundo Personalizado</button>
                        <button id="btn-save-current" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 0.9em;">Salvar Atual</button>
                    </div>
                </div>
                
                <button id="close-save-manager" style="margin-top: 15px; background: #666;">Voltar</button>
            </div>
        </div>

        <div id="debug-overlay">Debug Info</div>
        <div id="crosshair">+</div>
        
        <div id="tree-highlight" class="tree-highlight"></div>
        <div id="falling-leaves" class="falling-leaves"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let MAP_SIZE = 200;
        let mapSize = MAP_SIZE;
        
        let heightMap = [];
        let rockHeightMap = [];
        let terrainTypeMap = [];
        let compactionMap = [];
        let dirtTimestamps = {};
        let biomeMap = [];
        
        let worldConfig = {
            mapSize: 200,
            reliefIntensity: 50,
            smoothIterations: 3,
            maxSlope: 20,
            biomeBlend: 3,
            generateRivers: true,
            includeOcean: true,
            vegetationDensity: 70,
            startRegion: 'random',
            autoReforestation: true
        };
        
        const BIOME_AMAZONIA = 0;
        const BIOME_CERRADO = 1;
        const BIOME_CAATINGA = 2;
        const BIOME_MATA_ATLANTICA = 3;
        const BIOME_PAMPA = 4;
        const BIOME_PANTANAL = 5;
        const BIOME_COSTEIRA = 6;
        const BIOME_OCEANO = 7;
        const BIOME_MONTANHA = 8;
        
        const SLIP_START_SLOPE = 15;
        const MAX_CLIMB_SLOPE = 25;
        const CRITICAL_SLOPE = 30;
        const WARNING_COOLDOWN = 5000;
        
        const TREE_CONFIG = {
            density: 0.1,
            autoGrowth: true,
            growthTime: 120,
            seasonalEffects: true,
            maxTreesPerTile: 1,
            seedDropRate: 0.3,
            saplingDropRate: 0.2,
            woodPerTree: 2,
            maxHealth: 100,
            regrowthTime: 300
        };

        const TREE_TYPES = {
            PALM: {
                name: "Palmeira",
                color: 0x8b7355,
                leafColor: 0x2e8b57,
                height: { min: 8, max: 12 },
                radius: { min: 0.3, max: 0.5 },
                leaves: { min: 4, max: 6 },
                biomes: [BIOME_COSTEIRA, BIOME_OCEANO],
                seedCount: 1,
                growthStages: 5
            },
            AMAZON: {
                name: "√Årvore Amaz√¥nica",
                color: 0x654321,
                leafColor: 0x006400,
                height: { min: 20, max: 30 },
                radius: { min: 0.8, max: 1.2 },
                leaves: { min: 8, max: 12 },
                biomes: [BIOME_AMAZONIA, BIOME_MATA_ATLANTICA],
                seedCount: 3,
                growthStages: 7
            },
            CERRADO: {
                name: "√Årvore do Cerrado",
                color: 0x8b4513,
                leafColor: 0x556b2f,
                height: { min: 6, max: 10 },
                radius: { min: 0.4, max: 0.6 },
                leaves: { min: 3, max: 5 },
                biomes: [BIOME_CERRADO, BIOME_CAATINGA],
                seedCount: 2,
                growthStages: 4
            },
            PINE: {
                name: "Pinheiro",
                color: 0x5d4037,
                leafColor: 0x228b22,
                height: { min: 12, max: 18 },
                radius: { min: 0.5, max: 0.8 },
                leaves: { min: 6, max: 9 },
                biomes: [BIOME_PAMPA, BIOME_MATA_ATLANTICA],
                seedCount: 2,
                growthStages: 6
            },
            MANGROVE: {
                name: "Mangue",
                color: 0x8b5a2b,
                leafColor: 0x2f4f4f,
                height: { min: 4, max: 7 },
                radius: { min: 0.3, max: 0.6 },
                leaves: { min: 3, max: 4 },
                biomes: [BIOME_PANTANAL],
                seedCount: 1,
                growthStages: 4
            }
        };

        const SEASONS = {
            SPRING: { name: "Primavera", colorMultiplier: 1.2, growthMultiplier: 1.3 },
            SUMMER: { name: "Ver√£o", colorMultiplier: 1.0, growthMultiplier: 1.0 },
            AUTUMN: { name: "Outono", colorMultiplier: 0.8, growthMultiplier: 0.8 },
            WINTER: { name: "Inverno", colorMultiplier: 0.6, growthMultiplier: 0.5 }
        };

        let trees = [];
        let seedlings = [];
        let currentSeason = SEASONS.SUMMER;
        let seasonTimer = 0;
        const SEASON_DURATION = 300;
        let treeModels = {};
        let selectedTree = null;
        let selectedSeedling = null;
        
        let scene, camera, renderer;
        let terrain, waterMesh;
        let selectionHighlight, adjacentBordersHighlight, adjacentTilesHighlight;
        
        const TILE_SIZE = 4;
        const METERS_PER_TERRA = 0.1;

        let selectedSlot = 0;
        let shovelGroup = null;
        let pickaxeGroup = null;
        let armsGroup = null;
        let terraformWarningShown = false;
        let lastWarningTime = 0;

        let player = { x: 100, y: 100, z: 0, name: 'Explorador' };
        let keys = {};
        let mouseDown = { left: false, right: false };
        let currentAction = null;
        let inventory = { 
            dirt: 0, 
            sand: 0, 
            rock: 0,
            wood: 0,
            seeds: 0,
            saplings: 0
        };

        let terraformTarget = { valid: false };
        let raycaster = new THREE.Raycaster();
        let chatOpen = false;
        let menuOpen = false;
        let currentSlope = 0;

        let isFirstPerson = true;
        let cameraYaw = 0;
        let cameraPitch = 0.3;
        let targetYaw = 0;
        let targetPitch = 0.3;
        let cameraDistance = 15;
        let targetDistance = 15;
        const cameraHeight = 2.5;
        const cameraSmoothness = 0.1;
        const minPitch = -Math.PI / 2.1;
        const maxPitch = Math.PI / 2.1;

        let characterYaw = 0;
        const moveSpeed = 0.25;
        const runSpeed = 0.45;
        const acceleration = 0.02;
        const friction = 0.92;
        let vx = 0;
        let vz = 0;
        const baseJumpForce = 0.6;
        let verticalVelocity = 0;
        const gravity = 0.022;

        let gridLabelsEnabled = false;
        let gridLabelsContainer;
        let currentGridCenter = { x: -1, y: -1 };

        function isTileOccupied(worldX, worldZ) {
            const gridX = Math.floor(worldX / TILE_SIZE);
            const gridZ = Math.floor(worldZ / TILE_SIZE);

            for (const tree of trees) {
                const treeGridX = Math.floor(tree.x / TILE_SIZE);
                const treeGridZ = Math.floor(tree.z / TILE_SIZE);
                if (treeGridX === gridX && treeGridZ === gridZ) {
                    return true;
                }
            }

            for (const seedling of seedlings) {
                const seedlingGridX = Math.floor(seedling.x / TILE_SIZE);
                const seedlingGridZ = Math.floor(seedling.z / TILE_SIZE);
                if (seedlingGridX === gridX && seedlingGridZ === gridZ) {
                    return true;
                }
            }

            return false;
        }

        function initTreeSystem() {
            createTreeModels();
            generateInitialTrees();
            
            if (TREE_CONFIG.seasonalEffects) {
                setInterval(updateSeasons, 1000);
            }
            
            setInterval(updateTreeGrowth, 5000);
            setInterval(naturalRegeneration, 30000);
            
            updateTreeInventoryDisplay();
        }

        function createTreeModels() {
            for (const [type, config] of Object.entries(TREE_TYPES)) {
                treeModels[type] = createTreeGeometry(config);
            }
        }

        function createTreeGeometry(config) {
            const group = new THREE.Group();
            
            const trunkHeight = (config.height.min + config.height.max) / 2;
            const trunkRadius = (config.radius.min + config.radius.max) / 2;
            
            const trunkGeometry = new THREE.CylinderGeometry(
                trunkRadius * 0.8,
                trunkRadius,
                trunkHeight,
                8
            );
            
            const trunkMaterial = new THREE.MeshLambertMaterial({ 
                color: config.color 
            });
            
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.position.y = trunkHeight / 2;
            group.add(trunk);
            
            const leafCount = Math.floor((config.leaves.min + config.leaves.max) / 2);
            
            for (let i = 0; i < leafCount; i++) {
                const leafHeight = trunkHeight * 0.7 + (i / leafCount) * trunkHeight * 0.3;
                const leafRadius = trunkRadius * 2 + (i / leafCount) * trunkRadius * 3;
                
                const leafGeometry = new THREE.ConeGeometry(
                    leafRadius,
                    trunkHeight * 0.3,
                    8
                );
                
                const leafMaterial = new THREE.MeshLambertMaterial({ 
                    color: config.leafColor,
                    transparent: true,
                    opacity: 0.9
                });
                
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.castShadow = true;
                leaf.position.y = leafHeight;
                leaf.rotation.y = Math.random() * Math.PI * 2;
                group.add(leaf);
            }
            
            return group;
        }

        function generateInitialTrees() {
            const density = TREE_CONFIG.density * worldConfig.vegetationDensity / 100;
            
            for (let x = 0; x < mapSize - 1; x++) {
                for (let y = 0; y < mapSize - 1; y++) {
                    const biome = biomeMap[x][y];
                    const terrainType = terrainTypeMap[x][y];
                    
                    if (canHaveTree(x, y, biome, terrainType)) {
                        const treeCount = Math.floor(Math.random() * TREE_CONFIG.maxTreesPerTile * density);
                        
                        for (let i = 0; i < treeCount; i++) {
                            const worldX = (x + Math.random()) * TILE_SIZE;
                            const worldY = (y + Math.random()) * TILE_SIZE;
                            
                            if (isValidTreePosition(worldX, worldY)) {
                                createTreeAt(worldX, worldY, biome);
                            }
                        }
                    }
                }
            }
            
            console.log(`Sistema de √°rvores: ${trees.length} √°rvores geradas`);
        }

        function canHaveTree(x, y, biome, terrainType) {
            if (terrainType === 3 || terrainType === 5) return false;
            
            const height = heightMap[x][y];
            if (height < 0) return false;
            
            const neighbors = [
                [x+1, y], [x-1, y], [x, y+1], [x, y-1]
            ];
            
            let maxSlope = 0;
            for (const [nx, ny] of neighbors) {
                if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize) {
                    const slope = Math.abs(heightMap[nx][ny] - height);
                    maxSlope = Math.max(maxSlope, slope);
                }
            }
            
            if (maxSlope > 5) return false;
            
            return true;
        }

        function isValidTreePosition(x, y) {
            const minDistance = 2;
            
            for (const tree of trees) {
                const distance = Math.sqrt(
                    Math.pow(tree.x - x, 2) + 
                    Math.pow(tree.z - y, 2)
                );
                
                if (distance < minDistance) return false;
            }
            
            return true;
        }

        function createTreeAt(x, y, biome) {
            let treeType;
            
            switch(biome) {
                case BIOME_COSTEIRA:
                case BIOME_OCEANO:
                    treeType = 'PALM';
                    break;
                case BIOME_AMAZONIA:
                    treeType = 'AMAZON';
                    break;
                case BIOME_CERRADO:
                case BIOME_CAATINGA:
                    treeType = 'CERRADO';
                    break;
                case BIOME_PAMPA:
                    treeType = 'PINE';
                    break;
                case BIOME_PANTANAL:
                    treeType = 'MANGROVE';
                    break;
                case BIOME_MATA_ATLANTICA:
                    treeType = Math.random() > 0.5 ? 'AMAZON' : 'PINE';
                    break;
                default:
                    treeType = 'CERRADO';
            }
            
            const config = TREE_TYPES[treeType];
            const treeHeight = config.height.min + Math.random() * (config.height.max - config.height.min);
            const worldHeight = getHeightAt(x, y) + 0.1;
            
            const tree = {
                id: trees.length,
                type: treeType,
                x: x,
                y: worldHeight,
                z: y,
                height: treeHeight,
                health: TREE_CONFIG.maxHealth,
                growth: 1.0,
                age: 0,
                seedTimer: 0,
                model: null,
                boundingBox: null
            };
            
            createTreeModel(tree);
            trees.push(tree);
            return tree;
        }

        function createTreeModel(tree) {
            const config = TREE_TYPES[tree.type];
            const baseModel = treeModels[tree.type].clone();
            
            const growthScale = tree.growth;
            baseModel.scale.set(growthScale, growthScale, growthScale);
            baseModel.position.set(tree.x, tree.y, tree.z);
            baseModel.rotation.y = Math.random() * Math.PI * 2;
            
            if (TREE_CONFIG.seasonalEffects) {
                applySeasonalEffects(baseModel, config);
            }
            
            scene.add(baseModel);
            tree.model = baseModel;
            
            const box = new THREE.Box3().setFromObject(baseModel);
            tree.boundingBox = box;
            box.max.y = tree.y + (tree.height * 0.3 * growthScale);
        }

        function applySeasonalEffects(treeModel, config) {
            treeModel.traverse((child) => {
                if (child.isMesh) {
                    if (child.material.color) {
                        const originalColor = child.material.color.clone();
                        
                        if (child.material.color.getHex() === config.leafColor) {
                            let newColor;
                            
                            switch(currentSeason) {
                                case SEASONS.AUTUMN:
                                    newColor = new THREE.Color(
                                        Math.min(1, originalColor.r * 1.5),
                                        originalColor.g * 0.7,
                                        originalColor.b * 0.5
                                    );
                                    break;
                                case SEASONS.WINTER:
                                    if (Math.random() > 0.7) {
                                        newColor = new THREE.Color(0xf0f8ff);
                                    } else {
                                        newColor = originalColor.multiplyScalar(0.6);
                                    }
                                    break;
                                case SEASONS.SPRING:
                                    newColor = originalColor.multiplyScalar(1.2);
                                    break;
                                default:
                                    newColor = originalColor;
                            }
                            
                            child.material.color = newColor;
                        }
                    }
                }
            });
        }

        function updateSeasons() {
            seasonTimer++;
            
            if (seasonTimer >= SEASON_DURATION) {
                seasonTimer = 0;
                const seasons = Object.values(SEASONS);
                const currentIndex = seasons.indexOf(currentSeason);
                const nextIndex = (currentIndex + 1) % seasons.length;
                currentSeason = seasons[nextIndex];
                
                addChatMessage("Sistema", `Esta√ß√£o mudou para: ${currentSeason.name}`);
                updateAllTreesSeasonalEffects();
            }
        }

        function updateAllTreesSeasonalEffects() {
            for (const tree of trees) {
                if (tree.model) {
                    const config = TREE_TYPES[tree.type];
                    applySeasonalEffects(tree.model, config);
                }
            }
        }

        function updateTreeGrowth() {
            if (!TREE_CONFIG.autoGrowth) return;
            
            const growthAmount = 0.01 * currentSeason.growthMultiplier;
            
            for (const tree of trees) {
                if (tree.growth < 1.0) {
                    tree.growth = Math.min(1.0, tree.growth + growthAmount);
                    tree.age++;
                    
                    if (tree.model) {
                        tree.model.scale.set(tree.growth, tree.growth, tree.growth);
                    }
                }
                
                if (tree.growth >= 0.8 && Math.random() < 0.1) {
                    dropSeedsFromTree(tree);
                }
            }
            
            for (let i = seedlings.length - 1; i >= 0; i--) {
                const seedling = seedlings[i];
                seedling.growth += 0.05 * currentSeason.growthMultiplier;
                
                if (seedling.growth >= 1.0) {
                    const tree = createTreeAt(seedling.x, seedling.z, seedling.biome);
                    tree.growth = 0.3;
                    
                    if (seedling.model) {
                        scene.remove(seedling.model);
                    }
                    seedlings.splice(i, 1);
                } else {
                    updateSeedlingModel(seedling);
                }
            }
        }

        function createSeedling(x, z, biome) {
            const seedling = {
                id: seedlings.length,
                x: x,
                y: getHeightAt(x, z) + 0.1,
                z: z,
                biome: biome,
                growth: 0.1,
                type: getTreeTypeForBiome(biome),
                model: null
            };
            
            createSeedlingModel(seedling);
            seedlings.push(seedling);
            return seedling;
        }

        function createSeedlingModel(seedling) {
            const group = new THREE.Group();
            
            const stemGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.3, 4);
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0.15;
            group.add(stem);
            
            const leafGeometry = new THREE.ConeGeometry(0.15, 0.2, 4);
            const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x00aa00 });
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.position.y = 0.35;
            group.add(leaf);
            
            group.position.set(seedling.x, seedling.y, seedling.z);
            group.scale.set(seedling.growth, seedling.growth, seedling.growth);
            group.name = `seedling-${seedling.id}`;
            
            scene.add(group);
            seedling.model = group;
        }

        function updateSeedlingModel(seedling) {
            if (seedling.model) {
                seedling.model.scale.set(seedling.growth, seedling.growth, seedling.growth);
                
                if (seedling.growth > 0.5) {
                    seedling.model.children[1].material.color.setHex(0x00ff00);
                }
            }
        }

        function getTreeTypeForBiome(biome) {
            const types = [];
            
            for (const [type, config] of Object.entries(TREE_TYPES)) {
                if (config.biomes.includes(biome)) {
                    types.push(type);
                }
            }
            
            return types.length > 0 ? 
                   types[Math.floor(Math.random() * types.length)] : 
                   'CERRADO';
        }

        function chopTree(tree) {
            if (!tree || tree.health <= 0) return false;
            
            tree.health -= 25;
            createChoppingEffects(tree);
            
            if (tree.health <= 0) {
                collectTreeResources(tree);
                removeTree(tree.id);
                addChatMessage("Sistema", "√Årvore cortada!");
                return true;
            } else {
                addChatMessage("Sistema", "√Årvore danificada!");
                return false;
            }
        }

        function createChoppingEffects(tree) {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createWoodParticle(tree);
                }, i * 50);
            }
            
            if (tree.model) {
                tree.model.traverse((child) => {
                    if (child.isMesh) {
                        child.material.emissive = new THREE.Color(0x444444);
                        
                        setTimeout(() => {
                            child.material.emissive = new THREE.Color(0x000000);
                        }, 500);
                    }
                });
            }
        }

        function createWoodParticle(tree) {
            const particle = document.createElement('div');
            particle.className = 'leaf-particle';
            particle.style.background = '#8b4513';
            
            const screenPos = toScreenPosition(new THREE.Vector3(
                tree.x + (Math.random() - 0.5),
                tree.y + tree.height * 0.5,
                tree.z + (Math.random() - 0.5)
            ));
            
            particle.style.left = screenPos.x + 'px';
            particle.style.top = screenPos.y + 'px';
            
            document.getElementById('falling-leaves').appendChild(particle);
            
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 1000);
        }

        function collectTreeResources(tree) {
            const woodAmount = TREE_CONFIG.woodPerTree * tree.growth;
            inventory.wood += Math.floor(woodAmount);
            
            if (Math.random() < TREE_CONFIG.seedDropRate) {
                inventory.seeds += TREE_TYPES[tree.type].seedCount;
                addChatMessage("Recurso", `+${TREE_TYPES[tree.type].seedCount} sementes`);
            }
            
            if (Math.random() < TREE_CONFIG.saplingDropRate) {
                inventory.saplings++;
                addChatMessage("Recurso", "+1 muda");
            }
            
            updateTreeInventoryDisplay();
        }

        function removeTree(treeId) {
            const index = trees.findIndex(t => t.id === treeId);
            if (index !== -1) {
                const tree = trees[index];
                
                if (tree.model) {
                    scene.remove(tree.model);
                    tree.model.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
                
                trees.splice(index, 1);
                createFallingTreeEffect(tree);
                scheduleTreeRegeneration(tree.x, tree.z, tree.biome);
            }
        }

        function createFallingTreeEffect(tree) {
            createLeafParticles(tree, 20);
        }

        function createLeafParticles(tree, count) {
            const config = TREE_TYPES[tree.type];
            
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'leaf-particle';
                particle.style.background = `#${config.leafColor.toString(16).padStart(6, '0')}`;
                
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * tree.height * 0.3;
                
                const screenPos = toScreenPosition(new THREE.Vector3(
                    tree.x + Math.cos(angle) * radius,
                    tree.y + tree.height * 0.7 + Math.random() * tree.height * 0.3,
                    tree.z + Math.sin(angle) * radius
                ));
                
                particle.style.left = screenPos.x + 'px';
                particle.style.top = screenPos.y + 'px';
                particle.style.animation = `leaf-fall ${1 + Math.random() * 2}s linear forwards`;
                
                document.getElementById('falling-leaves').appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 3000);
            }
        }

        function scheduleTreeRegeneration(x, z, biome) {
            setTimeout(() => {
                if (isValidTreePosition(x, z)) {
                    createTreeAt(x, z, biome);
                    addChatMessage("Natureza", "Uma nova √°rvore cresceu!");
                }
            }, TREE_CONFIG.regrowthTime * 1000);
        }

        function naturalRegeneration() {
            if (trees.length < mapSize * mapSize * 0.01) {
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * mapSize * TILE_SIZE;
                    const z = Math.random() * mapSize * TILE_SIZE;
                    const gx = Math.floor(x / TILE_SIZE);
                    const gz = Math.floor(z / TILE_SIZE);
                    
                    if (gx >= 0 && gx < mapSize && gz >= 0 && gz < mapSize) {
                        const biome = biomeMap[gx][gz];
                        
                        if (!isTileOccupied(x, z) && isValidTreePosition(x, z) && canHaveTree(gx, gz, biome, terrainTypeMap[gx][gz])) {
                            createTreeAt(x, z, biome);
                        }
                    }
                }
            }
        }

        function dropSeedsFromTree(tree) {
            const config = TREE_TYPES[tree.type];
            const angle = Math.random() * Math.PI * 2;
            const distance = 1 + Math.random() * 3;
            
            const seedX = tree.x + Math.cos(angle) * distance;
            const seedZ = tree.z + Math.sin(angle) * distance;
            
            const gx = Math.floor(seedX / TILE_SIZE);
            const gz = Math.floor(seedZ / TILE_SIZE);
            
            if (gx >= 0 && gx < mapSize && gz >= 0 && gz < mapSize) {
                const biome = biomeMap[gx][gz];
                const terrainType = terrainTypeMap[gx][gz];
                
                if (canHaveTree(gx, gz, biome, terrainType) && isValidTreePosition(seedX, seedZ) && !isTileOccupied(seedX, seedZ)) {
                    createSeedling(seedX, seedZ, biome);
                }
            }
        }

        function updateTreeInventoryDisplay() {
            document.getElementById('inv-wood').textContent = inventory.wood;
            document.getElementById('inv-seeds').textContent = inventory.seeds;
            document.getElementById('inv-saplings').textContent = inventory.saplings;
        }

        function checkTreeCollision(x, z, radius = 0.5) {
            for (const tree of trees) {
                const distance = Math.sqrt(
                    Math.pow(tree.x - x, 2) + 
                    Math.pow(tree.z - z, 2)
                );
                
                if (distance < radius + (tree.growth * 0.5)) {
                    return tree;
                }
            }
            
            return null;
        }

        function updateTreeSelection() {
            selectedTree = null;
            selectedSeedling = null;
            
            document.getElementById('tree-info').style.display = 'none';
            document.getElementById('seedling-info').style.display = 'none';
            document.getElementById('tree-highlight').style.display = 'none';
            
            if (selectedSlot === 3 || selectedSlot === 4 || selectedSlot === 5) {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                let closestTree = null;
                let closestDistance = Infinity;
                
                for (const tree of trees) {
                    if (tree.model) {
                        const intersects = raycaster.intersectObject(tree.model, true);
                        if (intersects.length > 0) {
                            const distance = intersects[0].distance;
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestTree = tree;
                            }
                        }
                    }
                }
                
                let closestSeedling = null;
                let closestSeedlingDistance = Infinity;
                
                for (const seedling of seedlings) {
                    if (seedling.model) {
                        const intersects = raycaster.intersectObject(seedling.model, true);
                        if (intersects.length > 0) {
                            const distance = intersects[0].distance;
                            if (distance < closestSeedlingDistance) {
                                closestSeedlingDistance = distance;
                                closestSeedling = seedling;
                            }
                        }
                    }
                }
                
                if (closestTree && closestDistance < 10) {
                    selectedTree = closestTree;
                    showTreeInfo(closestTree);
                } else if (closestSeedling && closestSeedlingDistance < 10) {
                    selectedSeedling = closestSeedling;
                    showSeedlingInfo(closestSeedling);
                }
            }
        }

        function showTreeInfo(tree) {
            const config = TREE_TYPES[tree.type];
            const info = document.getElementById('tree-info');
            
            info.innerHTML = `
                <strong>${config.name}</strong><br>
                Sa√∫de: ${tree.health}/${TREE_CONFIG.maxHealth}<br>
                Idade: ${tree.age} ciclos<br>
                Tamanho: ${Math.round(tree.growth * 100)}%<br>
                Madeira: ~${Math.floor(TREE_CONFIG.woodPerTree * tree.growth)}<br>
                <div class="tree-health-bar">
                    <div class="tree-health-fill" style="width: ${tree.health}%"></div>
                </div>
            `;
            
            info.style.display = 'block';
            
            const screenPos = toScreenPosition(new THREE.Vector3(tree.x, tree.y + tree.height, tree.z));
            if (screenPos.visible) {
                const highlight = document.getElementById('tree-highlight');
                highlight.style.display = 'block';
                highlight.style.left = (screenPos.x - 20) + 'px';
                highlight.style.top = (screenPos.y - 20) + 'px';
                highlight.style.width = '40px';
                highlight.style.height = '40px';
            }
        }

        function showSeedlingInfo(seedling) {
            const config = TREE_TYPES[seedling.type];
            const info = document.getElementById('seedling-info');
            
            info.innerHTML = `
                <strong>Muda de ${config.name}</strong><br>
                Crescimento: ${Math.round(seedling.growth * 100)}%<br>
                <div class="growth-stage">
                    <div class="growth-fill" style="width: ${seedling.growth * 100}%"></div>
                </div>
            `;
            
            info.style.display = 'block';
        }

        function startGame() {
            initGame();
            setupMenuButtons();
            
            const saveManager = document.getElementById('save-manager');
            saveManager.style.display = 'flex';
            document.getElementById('close-save-manager').style.display = 'none';
            renderSaveList();
            
            setupWorldConfigSliders();
            initGridLabels();
            
            setTimeout(initTreeSystem, 1000);
        }

        startGame();

        function setupWorldConfigSliders() {
            const sliders = [
                { id: 'map-size-slider', valueId: 'map-size-value', format: v => v },
                { id: 'relief-slider', valueId: 'relief-value', format: v => v + '%' },
                { id: 'smooth-slider', valueId: 'smooth-value', format: v => v },
                { id: 'slope-slider', valueId: 'slope-value', format: v => v },
                { id: 'blend-slider', valueId: 'blend-value', format: v => v },
                { id: 'veg-slider', valueId: 'veg-value', format: v => v + '%' },
                { id: 'tree-density-slider', valueId: 'tree-density-value', format: v => v + '%' },
                { id: 'growth-time-slider', valueId: 'growth-time-value', format: v => v + 's' }
            ];
            
            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                
                element.addEventListener('input', function() {
                    valueElement.textContent = slider.format(this.value);
                    updateWorldPreview();
                });
            });
            
            document.getElementById('rivers-checkbox').addEventListener('change', updateWorldPreview);
            document.getElementById('ocean-checkbox').addEventListener('change', updateWorldPreview);
            document.getElementById('reforestation-checkbox').addEventListener('change', updateWorldPreview);
            document.getElementById('start-region').addEventListener('change', updateWorldPreview);
            document.getElementById('auto-growth-checkbox').addEventListener('change', function() {
                TREE_CONFIG.autoGrowth = this.checked;
                document.getElementById('auto-growth-value').textContent = this.checked ? 'Sim' : 'N√£o';
            });
            document.getElementById('seasonal-effects-checkbox').addEventListener('change', function() {
                TREE_CONFIG.seasonalEffects = this.checked;
            });
            document.getElementById('tree-density-slider').addEventListener('input', function() {
                TREE_CONFIG.density = this.value / 100;
            });
            document.getElementById('growth-time-slider').addEventListener('input', function() {
                TREE_CONFIG.growthTime = this.value;
            });
        }
        
        function updateWorldPreview() {
            const preview = document.getElementById('world-preview');
            const config = getWorldConfigFromUI();
            
            let description = "üåé ";
            description += config.mapSize + "√ó" + config.mapSize + " | ";
            description += "Rel: " + config.reliefIntensity + "% | ";
            description += "Inc: " + config.maxSlope + " | ";
            description += config.generateRivers ? "üåä " : "";
            description += config.includeOcean ? "üåÖ " : "";
            description += "üå≥ " + TREE_CONFIG.density * 100 + "%";
            
            preview.textContent = description;
        }
        
        function getWorldConfigFromUI() {
            return {
                mapSize: parseInt(document.getElementById('map-size-slider').value),
                reliefIntensity: parseInt(document.getElementById('relief-slider').value),
                smoothIterations: parseInt(document.getElementById('smooth-slider').value),
                maxSlope: parseInt(document.getElementById('slope-slider').value),
                biomeBlend: parseInt(document.getElementById('blend-slider').value),
                generateRivers: document.getElementById('rivers-checkbox').checked,
                includeOcean: document.getElementById('ocean-checkbox').checked,
                vegetationDensity: parseInt(document.getElementById('veg-slider').value),
                startRegion: document.getElementById('start-region').value,
                autoReforestation: document.getElementById('reforestation-checkbox').checked
            };
        }

        function setupMenuButtons() {
            const resumeBtn = document.getElementById('resume-btn');
            const openSavesBtn = document.getElementById('open-saves-btn');
            const menu = document.getElementById('menu');
            const saveManager = document.getElementById('save-manager');
            const closeSaveManagerBtn = document.getElementById('close-save-manager');
            const btnOpenWorldConfig = document.getElementById('btn-open-world-config');
            const btnSaveCurrent = document.getElementById('btn-save-current');
            const btnCancelConfig = document.getElementById('btn-cancel-config');
            const btnGenerateWorld = document.getElementById('btn-generate-world');
            const worldConfigModal = document.getElementById('world-config-modal');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const exitBtn = document.getElementById('btn-exit');

            resumeBtn.onclick = function (e) {
                e.preventDefault();
                e.stopPropagation();
                closeMenu();
                document.getElementById('game-canvas').requestPointerLock();
            };

            fullscreenBtn.onclick = function() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            };

            exitBtn.onclick = function() {
                window.close();
                window.location.href = "about:blank";
            };

            openSavesBtn.onclick = function(e) {
                e.preventDefault();
                menu.style.display = 'none';
                saveManager.style.display = 'flex';
                renderSaveList();
                document.getElementById('close-save-manager').style.display = 'block';
            };

            closeSaveManagerBtn.onclick = function() {
                saveManager.style.display = 'none';
                menu.style.display = 'flex';
            };

            btnOpenWorldConfig.onclick = function() {
                saveManager.style.display = 'none';
                worldConfigModal.style.display = 'flex';
                setupWorldConfigSliders();
                updateWorldPreview();
            };

            btnCancelConfig.onclick = function() {
                worldConfigModal.style.display = 'none';
                saveManager.style.display = 'flex';
            };

            btnGenerateWorld.onclick = function() {
                const name = document.getElementById('save-name-input').value.trim();
                if(!name) {
                    alert("Digite um nome para o save antes de gerar o mundo.");
                    return;
                }
                
                worldConfig = getWorldConfigFromUI();
                
                player.name = `Explorador${Math.floor(Math.random() * 1000)}`;
                document.getElementById('player-name-display').textContent = player.name;
                document.getElementById('player-info').style.display = 'block';

                generateBrazilTerrain(worldConfig);
                createTerrain();
                
                let startX, startY;
                const worldSize = mapSize * TILE_SIZE;
                
                switch(worldConfig.startRegion) {
                    case 'centro':
                        startX = worldSize * 0.5;
                        startY = worldSize * 0.55;
                        break;
                    case 'sudeste':
                        startX = worldSize * 0.75;
                        startY = worldSize * 0.6;
                        break;
                    case 'norte':
                        startX = worldSize * 0.5;
                        startY = worldSize * 0.3;
                        break;
                    case 'nordeste':
                        startX = worldSize * 0.8;
                        startY = worldSize * 0.45;
                        break;
                    case 'sul':
                        startX = worldSize * 0.4;
                        startY = worldSize * 0.8;
                        break;
                    case 'random':
                    default:
                        startX = worldSize * (0.3 + Math.random() * 0.4);
                        startY = worldSize * (0.3 + Math.random() * 0.4);
                        break;
                }
                
                player.x = startX;
                player.y = startY;
                player.z = (getHeightAt(player.x, player.y) || 0) + 5;
                
                inventory = { dirt: 0, sand: 0, rock: 0, wood: 0, seeds: 0, saplings: 0 };
                updateInventoryDisplay();
                updateTreeInventoryDisplay();
                
                initTreeSystem();
                
                saveGame(name);
                
                addChatMessage("SISTEMA", "Bem-vindo ao Brasil Geogr√°fico Personalizado!");
                addChatMessage("SISTEMA", `Tamanho do mapa: ${mapSize}x${mapSize}`);
                addChatMessage("SISTEMA", `Inclina√ß√£o m√°xima: ${worldConfig.maxSlope} unidades`);
                addChatMessage("SISTEMA", `Regi√£o inicial: ${document.getElementById('start-region').selectedOptions[0].text}`);
                addChatMessage("SISTEMA", "üå≥ Sistema de √Årvores ativado!");
                
                worldConfigModal.style.display = 'none';
                saveManager.style.display = 'none';
                closeMenu();
                document.getElementById('game-canvas').requestPointerLock();
            };

            btnSaveCurrent.onclick = function() {
                const name = document.getElementById('save-name-input').value.trim();
                if(!name) { 
                    alert("Digite um nome para o save."); 
                    return; 
                }
                saveGame(name);
            };
        }

        function getSaves() {
            const saves = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('animalysson_save_')) {
                    saves.push(key.replace('animalysson_save_', ''));
                }
            }
            return saves;
        }

        function getTreeDataForSave() {
            return {
                trees: trees.map(tree => ({
                    type: tree.type,
                    x: tree.x,
                    y: tree.y,
                    z: tree.z,
                    growth: tree.growth,
                    health: tree.health,
                    age: tree.age
                })),
                seedlings: seedlings.map(seedling => ({
                    x: seedling.x,
                    z: seedling.z,
                    biome: seedling.biome,
                    growth: seedling.growth,
                    type: seedling.type
                })),
                inventory: inventory,
                seasonTimer: seasonTimer,
                treeConfig: TREE_CONFIG
            };
        }

        function loadTreeData(data) {
            if (!data) return;
            
            trees.forEach(tree => {
                if (tree.model) {
                    scene.remove(tree.model);
                }
            });
            trees = [];
            seedlings = [];
            
            if (data.trees) {
                data.trees.forEach(treeData => {
                    const tree = {
                        ...treeData,
                        model: null,
                        boundingBox: null
                    };
                    createTreeModel(tree);
                    trees.push(tree);
                });
            }
            
            if (data.seedlings) {
                data.seedlings.forEach(seedlingData => {
                    const seedling = {
                        ...seedlingData,
                        model: null
                    };
                    createSeedlingModel(seedling);
                    seedlings.push(seedling);
                });
            }
            
            if (data.inventory) {
                inventory = { ...inventory, ...data.inventory };
                updateTreeInventoryDisplay();
            }
            
            if (data.seasonTimer) {
                seasonTimer = data.seasonTimer;
            }
            
            if (data.treeConfig) {
                Object.assign(TREE_CONFIG, data.treeConfig);
            }
        }

        function saveGame(saveName) {
            const treeData = getTreeDataForSave();
            const data = {
                heightMap, rockHeightMap, terrainTypeMap, compactionMap, biomeMap,
                player, inventory: { ...inventory }, mapSize, worldConfig,
                treeData: treeData,
                timestamp: Date.now()
            };
            
            try {
                localStorage.setItem('animalysson_save_' + saveName, JSON.stringify(data));
                addChatMessage("SISTEMA", `Jogo salvo: ${saveName}`);
                renderSaveList();
            } catch(e) {
                alert("Erro ao salvar. LocalStorage cheio?");
            }
        }

        window.loadGame = function(saveName) {
            const json = localStorage.getItem('animalysson_save_' + saveName);
            if (!json) return;
            const data = JSON.parse(json);
            
            heightMap = data.heightMap;
            rockHeightMap = data.rockHeightMap;
            terrainTypeMap = data.terrainTypeMap;
            compactionMap = data.compactionMap || [];
            biomeMap = data.biomeMap || [];
            player = data.player;
            document.getElementById('player-name-display').textContent = player.name;
            document.getElementById('player-info').style.display = 'block';
            inventory = data.inventory || inventory;
            mapSize = data.mapSize;
            worldConfig = data.worldConfig || worldConfig;
            
            createTerrain();
            
            if (data.treeData) {
                loadTreeData(data.treeData);
            } else {
                initTreeSystem();
            }
            
            updateInventoryDisplay();
            updateTreeInventoryDisplay();
            
            vx = 0; vz = 0; verticalVelocity = 0;
            
            addChatMessage("SISTEMA", `Jogo carregado: ${saveName}`);
            document.getElementById('save-manager').style.display = 'none';
            closeMenu();
            document.getElementById('game-canvas').requestPointerLock();
        };

        window.deleteSave = function(saveName) {
            if(confirm(`Excluir save '${saveName}'?`)) {
                localStorage.removeItem('animalysson_save_' + saveName);
                renderSaveList();
            }
        };

        window.renameSave = function(oldName) {
            const newName = prompt("Novo nome para o save:", oldName);
            if (newName && newName.trim() !== "" && newName !== oldName) {
                const oldKey = 'animalysson_save_' + oldName;
                const newKey = 'animalysson_save_' + newName.trim();
                
                if (localStorage.getItem(newKey)) {
                    alert("J√° existe um save com este nome!");
                    return;
                }
                
                const data = localStorage.getItem(oldKey);
                if (data) {
                    localStorage.setItem(newKey, data);
                    localStorage.removeItem(oldKey);
                    renderSaveList();
                }
            }
        };

        function renderSaveList() {
            const list = document.getElementById('save-list');
            list.innerHTML = '';
            const saves = getSaves();
            
            if (saves.length === 0) {
                list.innerHTML = '<div style="padding:10px; color:#666; text-align:center;">Nenhum save encontrado.</div>';
                return;
            }

            saves.forEach(name => {
                const item = document.createElement('div');
                item.className = 'save-item';
                item.innerHTML = `
                    <span class="save-name" onclick="document.getElementById('save-name-input').value = '${name}'" style="cursor:pointer;" title="Clique para selecionar">${name}</span>
                    <div class="save-actions">
                        <button class="btn-load" onclick="loadGame('${name}')">Carregar</button>
                        <button class="btn-rename" onclick="renameSave('${name}')">Renomear</button>
                        <button class="btn-delete" onclick="deleteSave('${name}')">Excluir</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function generateBrazilTerrain(config = worldConfig) {
            mapSize = config.mapSize;
            MAP_SIZE = mapSize;
            
            heightMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(0));
            rockHeightMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(0));
            terrainTypeMap = Array.from({ length: mapSize - 1 }, () => Array(mapSize - 1).fill(0));
            compactionMap = Array.from({ length: mapSize - 1 }, () => Array(mapSize - 1).fill(0));
            biomeMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(BIOME_OCEANO));
            
            for (let x = 0; x < mapSize; x++) {
                for (let y = 0; y < mapSize; y++) {
                    const nx = x / mapSize;
                    const ny = y / mapSize;
                    
                    const regionInfo = getBrazilRegionAndBiome(nx, ny);
                    const biome = regionInfo.biome;
                    
                    const baseHeight = calculateBrazilHeight(nx, ny, regionInfo);
                    const intensity = config.reliefIntensity / 100;
                    
                    let height = baseHeight * intensity;
                    
                    let noise = fractalNoise(nx * 5, ny * 5, 4) * 50 * intensity;
                    height += noise;
                    
                    let rockHeight = height - 3 - Math.random() * 2;
                    
                    if (biome === BIOME_PANTANAL) {
                        rockHeight = height - 1;
                    } else if (biome === BIOME_MONTANHA) {
                        rockHeight = height - 5;
                    }
                    
                    heightMap[x][y] = Math.max(-10, Math.round(height));
                    rockHeightMap[x][y] = Math.round(rockHeight);
                    biomeMap[x][y] = biome;
                }
            }
            
            for (let i = 0; i < config.smoothIterations; i++) {
                smoothTerrainAdvanced(1, 2);
            }
            
            applySlopeConstraint(config.maxSlope);
            
            if (config.generateRivers) {
                generateRivers();
            }
            
            smoothTerrain(1);
            
            applyBiomeBlending(config.biomeBlend);
            
            generateTerrainTypesFromBiomes(config.vegetationDensity);
        }
        
        function getBrazilRegionAndBiome(nx, ny) {
            const smoothTransition = (value, threshold, width = 0.05) => {
                return Math.max(0, Math.min(1, (value - (threshold - width/2)) / width));
            };
            
            const isNorth = smoothTransition(ny, 0.45, 0.1) < 0.5;
            const isWest = smoothTransition(nx, 0.15, 0.1) > 0.5;
            const isEast = smoothTransition(nx, 0.85, 0.1) < 0.5;
            
            if (isNorth && isWest && isEast) {
                if (ny > 0.75 * nx - 0.4) {
                    const amazonRiverY = 0.25 + 0.05 * Math.sin(nx * 8);
                    const riverDist = Math.abs(ny - amazonRiverY);
                    if (riverDist < 0.04) {
                        return { region: 'NORTE', subregion: 'RIO_AMAZONAS', biome: BIOME_AMAZONIA };
                    }
                    
                    if (ny < 0.2) {
                        const plateauMix = 1 - smoothTransition(ny, 0.15, 0.05);
                        if (plateauMix > 0.7) {
                            return { region: 'NORTE', subregion: 'PLANALTO_GUIANAS', biome: BIOME_MONTANHA };
                        }
                    }
                    
                    return { region: 'NORTE', subregion: 'FLORESTA_AMAZONICA', biome: BIOME_AMAZONIA };
                }
            }
            
            const isNortheastY = smoothTransition(ny, 0.35, 0.1) > 0.5 && smoothTransition(ny, 0.65, 0.1) < 0.5;
            const isNortheastX = smoothTransition(nx, 0.65, 0.1) > 0.5;
            
            if (isNortheastY && isNortheastX) {
                const coastFactor = smoothTransition(nx, 0.85, 0.05);
                if (coastFactor > 0.7) {
                    return { region: 'NORDESTE', subregion: 'LITORAL', biome: BIOME_COSTEIRA };
                }
                
                if (nx > 0.72 && nx < 0.82 && ny > 0.4 && ny < 0.5) {
                    const chapadaFactor = 1 - Math.sqrt(Math.pow((nx-0.77)/0.05, 2) + Math.pow((ny-0.45)/0.05, 2));
                    if (chapadaFactor > 0.5) {
                        return { region: 'NORDESTE', subregion: 'CHAPADA_DIAMANTINA', biome: BIOME_CERRADO };
                    }
                }
                
                return { region: 'NORDESTE', subregion: 'SERTAO', biome: BIOME_CAATINGA };
            }
            
            const isCenterWestY = smoothTransition(ny, 0.35, 0.1) > 0.5 && smoothTransition(ny, 0.75, 0.1) < 0.5;
            const isCenterWestX = smoothTransition(nx, 0.3, 0.1) > 0.5 && smoothTransition(nx, 0.7, 0.1) < 0.5;
            
            if (isCenterWestY && isCenterWestX) {
                if (nx < 0.45 && ny > 0.55) {
                    const pantanalFactor = 1 - Math.sqrt(Math.pow((nx-0.4)/0.1, 2) + Math.pow((ny-0.6)/0.05, 2));
                    if (pantanalFactor > 0.3) {
                        return { region: 'CENTRO_OESTE', subregion: 'PANTANAL', biome: BIOME_PANTANAL };
                    }
                }
                
                if (nx > 0.45 && nx < 0.55 && ny > 0.45 && ny < 0.55) {
                    const veadeirosFactor = 1 - Math.sqrt(Math.pow((nx-0.5)/0.05, 2) + Math.pow((ny-0.5)/0.05, 2));
                    if (veadeirosFactor > 0.5) {
                        return { region: 'CENTRO_OESTE', subregion: 'CHAPADA_VEADEIROS', biome: BIOME_MONTANHA };
                    }
                }
                
                return { region: 'CENTRO_OESTE', subregion: 'CERRADO', biome: BIOME_CERRADO };
            }
            
            const isSoutheastY = smoothTransition(ny, 0.45, 0.1) > 0.5 && smoothTransition(ny, 0.75, 0.1) < 0.5;
            const isSoutheastX = smoothTransition(nx, 0.65, 0.1) > 0.5;
            
            if (isSoutheastY && isSoutheastX) {
                if (nx < 0.75) {
                    const serraFactor = smoothTransition(nx, 0.7, 0.05);
                    if (serraFactor < 0.5) {
                        return { region: 'SUDESTE', subregion: 'SERRA_DO_MAR', biome: BIOME_MATA_ATLANTICA };
                    }
                }
                
                if (nx > 0.7 && nx < 0.8 && ny > 0.55 && ny < 0.65) {
                    const mantiqueiraFactor = 1 - Math.sqrt(Math.pow((nx-0.75)/0.05, 2) + Math.pow((ny-0.6)/0.05, 2));
                    if (mantiqueiraFactor > 0.5) {
                        return { region: 'SUDESTE', subregion: 'SERRA_MANTIQUEIRA', biome: BIOME_MONTANHA };
                    }
                }
                
                return { region: 'SUDESTE', subregion: 'PLANALTO_ATLANTICO', biome: BIOME_MATA_ATLANTICA };
            }
            
            const isSouth = smoothTransition(ny, 0.65, 0.1) > 0.5;
            const isSouthX = smoothTransition(nx, 0.2, 0.1) > 0.5 && smoothTransition(nx, 0.6, 0.1) < 0.5;
            
            if (isSouth && isSouthX) {
                if (nx < 0.4) {
                    const serraGeralFactor = 1 - Math.abs(nx - 0.35) / 0.05;
                    if (serraGeralFactor > 0.5) {
                        return { region: 'SUL', subregion: 'SERRA_GERAL', biome: BIOME_MATA_ATLANTICA };
                    }
                }
                
                if (ny > 0.8) {
                    const pampaFactor = smoothTransition(ny, 0.8, 0.05);
                    if (pampaFactor > 0.7) {
                        return { region: 'SUL', subregion: 'PAMPA', biome: BIOME_PAMPA };
                    }
                }
                
                return { region: 'SUL', subregion: 'PLANALTO_MERIDIONAL', biome: BIOME_CERRADO };
            }
            
            return { region: 'OCEANO', subregion: 'ATLANTICO', biome: BIOME_OCEANO };
        }
        
        function calculateBrazilHeight(nx, ny, regionInfo) {
            const { region, subregion } = regionInfo;
            let height = 10;
            
            let noise = fractalNoise(nx * 5, ny * 5, 4) * 50;
            
            switch (region) {
                case 'NORTE':
                    if (subregion === 'RIO_AMAZONAS') {
                        height = 5 + noise * 0.2;
                    } else if (subregion === 'PLANALTO_GUIANAS') {
                        height = 500 + (0.2 - ny) * 1500 + noise * 2;
                        if (nx > 0.25 && nx < 0.35 && ny < 0.1) {
                            height += 500 + Math.sin(nx * 30) * 200;
                        }
                    } else {
                        height = 50 + noise * 0.8;
                    }
                    break;
                    
                case 'NORDESTE':
                    if (subregion === 'LITORAL') {
                        height = Math.max(5, 100 - (nx - 0.85) * 300 + noise * 0.5);
                    } else if (subregion === 'CHAPADA_DIAMANTINA') {
                        height = 800 + Math.sin(nx * 20) * 200 + noise * 2;
                        if (nx > 0.76 && nx < 0.78 && ny > 0.44 && ny < 0.46) {
                            height += 300;
                        }
                    } else {
                        height = 300 + noise;
                    }
                    break;
                    
                case 'CENTRO_OESTE':
                    if (subregion === 'PANTANAL') {
                        height = 80 + noise * 0.3;
                        if (fractalNoise(nx * 10, ny * 10, 2) > 0.3) {
                            height = 50 + noise * 0.2;
                        }
                    } else if (subregion === 'CHAPADA_VEADEIROS') {
                        height = 1200 + Math.sin(nx * 25) * 300 + noise * 3;
                    } else {
                        height = 500 + noise;
                    }
                    break;
                    
                case 'SUDESTE':
                    if (subregion === 'SERRA_DO_MAR') {
                        const distanceFromCoast = Math.max(0, nx - 0.7);
                        height = 1200 * (1 - distanceFromCoast * 2) + 200;
                        height = Math.max(200, height + noise * 2);
                    } else if (subregion === 'SERRA_MANTIQUEIRA') {
                        height = 1800 + Math.sin(ny * 30) * 400 + noise * 3;
                        if (nx > 0.74 && nx < 0.76 && ny > 0.58 && ny < 0.62) {
                            height += 500;
                        }
                    } else {
                        height = 800 + noise * 1.5;
                    }
                    break;
                    
                case 'SUL':
                    if (subregion === 'SERRA_GERAL') {
                        height = 900 + noise * 2;
                        if (Math.abs(nx - 0.35) < 0.02) {
                            height += 200;
                        }
                    } else if (subregion === 'PAMPA') {
                        height = 100 + noise * 0.5;
                    } else {
                        height = 600 + noise;
                    }
                    break;
                    
                case 'OCEANO':
                default:
                    height = -10 + noise * 2;
                    break;
            }
            
            return Math.max(-15, Math.min(3000, height));
        }
        
        function fractalNoise(x, y, octaves) {
            let total = 0;
            let frequency = 1;
            let amplitude = 1;
            let maxValue = 0;
            
            for (let i = 0; i < octaves; i++) {
                total += perlinNoise(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return total / maxValue;
        }
        
        function perlinNoise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            
            const u = fade(x);
            const v = fade(y);
            
            const a = p[X] + Y;
            const b = p[X + 1] + Y;
            
            return lerp(v, lerp(u, grad(p[a], x, y), grad(p[b], x - 1, y)),
                           lerp(u, grad(p[a + 1], x, y - 1), grad(p[b + 1], x - 1, y - 1)));
        }
        
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        
        const p = new Array(512);
        const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,
            140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,
            197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,
            136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,
            122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,
            1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,
            164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,
            255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,
            119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,
            19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,
            193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,
            214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,
            236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
        
        for (let i = 0; i < 256; i++) {
            p[256 + i] = p[i] = permutation[i];
        }
        
        function applySlopeConstraint(maxSlope) {
            const originalHeight = heightMap.map(row => [...row]);
            let changed = true;
            let iterations = 0;
            const maxIterations = 100;
            
            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;
                
                for (let x = 0; x < mapSize; x++) {
                    for (let y = 0; y < mapSize; y++) {
                        const neighbors = [
                            [x + 1, y], [x, y + 1], [x - 1, y], [x, y - 1],
                            [x + 1, y + 1], [x - 1, y + 1], [x + 1, y - 1], [x - 1, y - 1]
                        ];
                        
                        for (const [nx, ny] of neighbors) {
                            if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize) {
                                const diff = heightMap[x][y] - heightMap[nx][ny];
                                
                                if (Math.abs(diff) > maxSlope) {
                                    const adjustment = Math.sign(diff) * (Math.abs(diff) - maxSlope) * 0.3;
                                    const newHeight = heightMap[x][y] - adjustment;
                                    
                                    if (newHeight > rockHeightMap[x][y] + 0.5) {
                                        heightMap[x][y] = newHeight;
                                        changed = true;
                                    } else {
                                        heightMap[x][y] = rockHeightMap[x][y] + 1;
                                        changed = true;
                                    }
                                }
                            }
                        }
                    }
                }
                
                smoothTerrain(1);
            }
            
            for (let x = 0; x < mapSize; x++) {
                for (let y = 0; y < mapSize; y++) {
                    const maxChange = 10;
                    if (Math.abs(heightMap[x][y] - originalHeight[x][y]) > maxChange) {
                        heightMap[x][y] = originalHeight[x][y] + 
                            Math.sign(heightMap[x][y] - originalHeight[x][y]) * maxChange;
                    }
                }
            }
        }
        
        function smoothTerrainAdvanced(iterations, kernelSize = 2) {
            const kernelRadius = Math.floor(kernelSize / 2);
            
            for (let iter = 0; iter < iterations; iter++) {
                const newHeightMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(0));
                
                for (let x = 0; x < mapSize; x++) {
                    for (let y = 0; y < mapSize; y++) {
                        let sum = 0;
                        let weightSum = 0;
                        
                        for (let kx = -kernelRadius; kx <= kernelRadius; kx++) {
                            for (let ky = -kernelRadius; ky <= kernelRadius; ky++) {
                                const nx = x + kx;
                                const ny = y + ky;
                                
                                if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize) {
                                    const distance = Math.sqrt(kx*kx + ky*ky);
                                    const weight = Math.exp(-distance * distance / (2 * kernelRadius * kernelRadius));
                                    
                                    sum += heightMap[nx][ny] * weight;
                                    weightSum += weight;
                                }
                            }
                        }
                        
                        newHeightMap[x][y] = Math.round(sum / weightSum);
                    }
                }
                
                heightMap = newHeightMap;
            }
        }
        
        function smoothTerrain(iterations) {
            for (let iter = 0; iter < iterations; iter++) {
                const newHeightMap = Array.from({ length: mapSize }, () => Array(mapSize).fill(0));
                
                for (let x = 0; x < mapSize; x++) {
                    for (let y = 0; y < mapSize; y++) {
                        let sum = heightMap[x][y];
                        let count = 1;
                        
                        if (x > 0) { sum += heightMap[x-1][y]; count++; }
                        if (x < mapSize-1) { sum += heightMap[x+1][y]; count++; }
                        if (y > 0) { sum += heightMap[x][y-1]; count++; }
                        if (y < mapSize-1) { sum += heightMap[x][y+1]; count++; }
                        
                        newHeightMap[x][y] = Math.round(sum / count);
                    }
                }
                
                heightMap = newHeightMap;
            }
        }
        
        function applyBiomeBlending(blendStrength) {
            if (blendStrength <= 1) return;
            
            const originalBiomes = biomeMap.map(row => [...row]);
            
            for (let x = 0; x < mapSize; x++) {
                for (let y = 0; y < mapSize; y++) {
                    const currentBiome = originalBiomes[x][y];
                    let biomeCounts = new Array(9).fill(0);
                    
                    const radius = Math.min(blendStrength, 5);
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dy = -radius; dy <= radius; dy++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize) {
                                const distance = Math.sqrt(dx*dx + dy*dy);
                                if (distance <= radius) {
                                    const neighborBiome = originalBiomes[nx][ny];
                                    const weight = 1.0 - (distance / radius);
                                    biomeCounts[neighborBiome] += weight;
                                }
                            }
                        }
                    }
                    
                    let maxCount = 0;
                    let dominantBiome = currentBiome;
                    for (let i = 0; i < biomeCounts.length; i++) {
                        if (biomeCounts[i] > maxCount) {
                            maxCount = biomeCounts[i];
                            dominantBiome = i;
                        }
                    }
                    
                    if (currentBiome !== BIOME_OCEANO || dominantBiome !== BIOME_OCEANO) {
                        biomeMap[x][y] = dominantBiome;
                    }
                }
            }
        }
        
        function generateRivers() {
            for (let x = 0; x < mapSize; x++) {
                const nx = x / mapSize;
                const riverCenterY = 0.25 + 0.05 * Math.sin(nx * 8);
                const riverY = Math.round(riverCenterY * mapSize);
                
                const riverWidth = Math.round((0.5 + 0.3 * Math.sin(nx * Math.PI)) * 8);
                
                for (let w = -riverWidth; w <= riverWidth; w++) {
                    const y = riverY + w;
                    if (y >= 0 && y < mapSize) {
                        const depth = 10 * (1 - Math.pow(Math.abs(w) / riverWidth, 2));
                        heightMap[x][y] = Math.max(-5, heightMap[x][y] - depth);
                        biomeMap[x][y] = BIOME_AMAZONIA;
                    }
                }
            }
            
            for (let x = Math.round(0.6 * mapSize); x < Math.round(0.85 * mapSize); x++) {
                const progress = (x - 0.6 * mapSize) / (0.25 * mapSize);
                const riverY = 0.55 + 0.1 * Math.sin(progress * 4);
                const y = Math.round(riverY * mapSize);
                
                if (y >= 0 && y < mapSize) {
                    const riverWidth = 3;
                    for (let w = -riverWidth; w <= riverWidth; w++) {
                        const currentY = y + w;
                        if (currentY >= 0 && currentY < mapSize) {
                            const depth = 8 * (1 - Math.abs(w) / riverWidth);
                            heightMap[x][currentY] = Math.max(0, heightMap[x][currentY] - depth);
                        }
                    }
                }
            }
            
            smoothTerrain(2);
        }
        
        function generateTerrainTypesFromBiomes(vegetationDensity = 70) {
            const vegProb = vegetationDensity / 100;
            
            for (let x = 0; x < mapSize - 1; x++) {
                for (let y = 0; y < mapSize - 1; y++) {
                    const biome = biomeMap[x][y];
                    const h1 = heightMap[x][y];
                    const h2 = heightMap[x+1][y];
                    const h3 = heightMap[x][y+1];
                    const h4 = heightMap[x+1][y+1];
                    const avgH = (h1 + h2 + h3 + h4) / 4;
                    
                    const r1 = rockHeightMap[x][y];
                    const r2 = rockHeightMap[x+1][y];
                    const r3 = rockHeightMap[x][y+1];
                    const r4 = rockHeightMap[x+1][y+1];
                    const isRock = (h1 <= r1) && (h2 <= r2) && (h3 <= r3) && (h4 <= r4);
                    
                    let type = 0;
                    
                    if (isRock) {
                        type = 5;
                    } else if (avgH <= 0) {
                        type = 3;
                    } else {
                        switch (biome) {
                            case BIOME_AMAZONIA:
                                type = Math.random() < vegProb ? 0 : 1;
                                if (avgH < 20 && Math.random() > 0.7) type = 3;
                                break;
                                
                            case BIOME_CERRADO:
                                type = Math.random() > 0.7 ? 1 : 0;
                                if (avgH > 800 && Math.random() > 0.8) type = 4;
                                break;
                                
                            case BIOME_CAATINGA:
                                type = Math.random() < 0.8 ? 1 : 2;
                                break;
                                
                            case BIOME_MATA_ATLANTICA:
                                type = Math.random() < vegProb ? 0 : 1;
                                if (avgH > 1000) type = Math.random() > 0.5 ? 4 : 5;
                                break;
                                
                            case BIOME_PAMPA:
                                type = Math.random() < vegProb ? 0 : 1;
                                break;
                                
                            case BIOME_PANTANAL:
                                type = 3;
                                if (avgH < 5 && Math.random() < vegProb) type = 0;
                                break;
                                
                            case BIOME_COSTEIRA:
                                type = avgH < 10 ? 3 : (Math.random() < vegProb ? 0 : 1);
                                break;
                                
                            case BIOME_MONTANHA:
                                if (avgH > 1500) {
                                    type = 5;
                                } else {
                                    type = Math.random() > 0.7 ? 4 : 0;
                                }
                                break;
                                
                            case BIOME_OCEANO:
                            default:
                                type = 3;
                                break;
                        }
                    }
                    
                    terrainTypeMap[x][y] = type;
                }
            }
        }

        function initGridLabels() {
            gridLabelsContainer = document.createElement('div');
            gridLabelsContainer.id = 'grid-labels-container';
            gridLabelsContainer.style.position = 'absolute';
            gridLabelsContainer.style.top = '0';
            gridLabelsContainer.style.left = '0';
            gridLabelsContainer.style.width = '100%';
            gridLabelsContainer.style.height = '100%';
            gridLabelsContainer.style.pointerEvents = 'none';
            gridLabelsContainer.style.overflow = 'hidden';
            gridLabelsContainer.style.zIndex = '1000';
            document.getElementById('game-container').appendChild(gridLabelsContainer);
        }

        function updateGridLabelsForAdjacentArea(cx, cy) {
            if (!gridLabelsEnabled || !gridLabelsContainer || (cx === currentGridCenter.x && cy === currentGridCenter.y)) {
                return;
            }
            
            currentGridCenter = { x: cx, y: cy };
            clearGridLabels();
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const x = cx + dx;
                    const y = cy + dy;
                    if (x >= 0 && x < mapSize && y >= 0 && y < mapSize) {
                        createVertexLabel(x, y);
                    }
                }
            }
            
            for (let dx = -1; dx <= 0; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const x = cx + dx;
                    const y = cy + dy;
                    if (x >= 0 && x < mapSize - 1 && y >= 0 && y < mapSize) {
                        createHorizontalEdgeLabel(x, y);
                    }
                }
            }
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 0; dy++) {
                    const x = cx + dx;
                    const y = cy + dy;
                    if (x >= 0 && x < mapSize && y >= 0 && y < mapSize - 1) {
                        createVerticalEdgeLabel(x, y);
                    }
                }
            }
        }

        function clearGridLabels() {
            if (gridLabelsContainer) {
                gridLabelsContainer.innerHTML = '';
            }
            currentGridCenter = { x: -1, y: -1 };
        }

        function createVertexLabel(x, y) {
            if (!gridLabelsContainer || !gridLabelsEnabled) return;
            
            const height = heightMap[x][y];
            const worldX = x * TILE_SIZE;
            const worldZ = y * TILE_SIZE;
            const worldY = height * METERS_PER_TERRA + 0.2;
            
            const screenPos = toScreenPosition(new THREE.Vector3(worldX, worldY, worldZ));
            if (!screenPos.visible) return;
            
            const label = document.createElement('div');
            label.className = 'grid-label vertex-label';
            label.textContent = `${height}`;
            label.dataset.type = 'vertex';
            label.dataset.x = x;
            label.dataset.y = y;
            label.style.left = screenPos.x + 'px';
            label.style.top = screenPos.y + 'px';
            label.style.display = 'block';
            
            const distance = camera.position.distanceTo(new THREE.Vector3(worldX, worldY, worldZ));
            const fontSize = Math.max(8, Math.min(12, 200 / distance));
            label.style.fontSize = fontSize + 'px';
            
            gridLabelsContainer.appendChild(label);
            return label;
        }

        function createHorizontalEdgeLabel(x, y) {
            if (!gridLabelsContainer || !gridLabelsEnabled) return;
            
            const h1 = heightMap[x][y];
            const h2 = heightMap[x + 1][y];
            const diff = Math.abs(h2 - h1);
            
            const worldX1 = x * TILE_SIZE;
            const worldX2 = (x + 1) * TILE_SIZE;
            const worldZ = y * TILE_SIZE;
            const worldY1 = h1 * METERS_PER_TERRA + 0.2;
            const worldY2 = h2 * METERS_PER_TERRA + 0.2;
            
            const midX = (worldX1 + worldX2) / 2;
            const midY = (worldY1 + worldY2) / 2;
            const midZ = worldZ;
            
            const screenPos = toScreenPosition(new THREE.Vector3(midX, midY, midZ));
            if (!screenPos.visible) return;
            
            const label = document.createElement('div');
            label.className = 'grid-label edge-label';
            label.textContent = `‚Üî ${diff}`;
            label.title = `Diferen√ßa: ${h1} ‚Üí ${h2}`;
            label.dataset.type = 'edge-h';
            label.dataset.x = x;
            label.dataset.y = y;
            label.style.left = screenPos.x + 'px';
            label.style.top = screenPos.y + 'px';
            label.style.display = 'block';
            
            const distance = camera.position.distanceTo(new THREE.Vector3(midX, midY, midZ));
            const fontSize = Math.max(6, Math.min(10, 180 / distance));
            label.style.fontSize = fontSize + 'px';
            
            gridLabelsContainer.appendChild(label);
            return label;
        }

        function createVerticalEdgeLabel(x, y) {
            if (!gridLabelsContainer || !gridLabelsEnabled) return;
            
            const h1 = heightMap[x][y];
            const h2 = heightMap[x][y + 1];
            const diff = Math.abs(h2 - h1);
            
            const worldX = x * TILE_SIZE;
            const worldZ1 = y * TILE_SIZE;
            const worldZ2 = (y + 1) * TILE_SIZE;
            const worldY1 = h1 * METERS_PER_TERRA + 0.2;
            const worldY2 = h2 * METERS_PER_TERRA + 0.2;
            
            const midX = worldX;
            const midY = (worldY1 + worldY2) / 2;
            const midZ = (worldZ1 + worldZ2) / 2;
            
            const screenPos = toScreenPosition(new THREE.Vector3(midX, midY, midZ));
            if (!screenPos.visible) return;
            
            const label = document.createElement('div');
            label.className = 'grid-label edge-label';
            label.textContent = `‚Üï ${diff}`;
            label.title = `Diferen√ßa: ${h1} ‚Üí ${h2}`;
            label.dataset.type = 'edge-v';
            label.dataset.x = x;
            label.dataset.y = y;
            label.style.left = screenPos.x + 'px';
            label.style.top = screenPos.y + 'px';
            label.style.display = 'block';
            
            const distance = camera.position.distanceTo(new THREE.Vector3(midX, midY, midZ));
            const fontSize = Math.max(6, Math.min(10, 180 / distance));
            label.style.fontSize = fontSize + 'px';
            
            gridLabelsContainer.appendChild(label);
            return label;
        }

        function updateGridLabelsAfterTerraform(x, y) {
            if (!gridLabelsEnabled) return;
            updateGridLabelsForAdjacentArea(x, y);
        }

        function updateVisibleGridLabels() {
            if (!gridLabelsEnabled || !gridLabelsContainer) return;
            
            const labels = gridLabelsContainer.querySelectorAll('.grid-label');
            labels.forEach(label => {
                const x = parseInt(label.dataset.x);
                const y = parseInt(label.dataset.y);
                const type = label.dataset.type;
                
                let worldX, worldY, worldZ;
                
                if (type === 'vertex') {
                    const height = heightMap[x][y];
                    worldX = x * TILE_SIZE;
                    worldZ = y * TILE_SIZE;
                    worldY = height * METERS_PER_TERRA + 0.2;
                } else if (type === 'edge-h') {
                    const h1 = heightMap[x][y];
                    const h2 = heightMap[x + 1][y];
                    worldX = (x + 0.5) * TILE_SIZE;
                    worldZ = y * TILE_SIZE;
                    worldY = ((h1 + h2) / 2) * METERS_PER_TERRA + 0.2;
                } else if (type === 'edge-v') {
                    const h1 = heightMap[x][y];
                    const h2 = heightMap[x][y + 1];
                    worldX = x * TILE_SIZE;
                    worldZ = (y + 0.5) * TILE_SIZE;
                    worldY = ((h1 + h2) / 2) * METERS_PER_TERRA + 0.2;
                }
                
                const screenPos = toScreenPosition(new THREE.Vector3(worldX, worldY, worldZ));
                if (screenPos.visible) {
                    label.style.display = 'block';
                    label.style.left = screenPos.x + 'px';
                    label.style.top = screenPos.y + 'px';
                    
                    const distance = camera.position.distanceTo(new THREE.Vector3(worldX, worldY, worldZ));
                    const fontSize = type === 'vertex' 
                        ? Math.max(8, Math.min(12, 200 / distance))
                        : Math.max(6, Math.min(10, 180 / distance));
                    label.style.fontSize = fontSize + 'px';
                } else {
                    label.style.display = 'none';
                }
            });
        }

        function updateGridVisibility() {
            if (selectedSlot === 1 || selectedSlot === 2) {
                if (!gridLabelsEnabled) {
                    gridLabelsEnabled = true;
                }
            } else {
                if (gridLabelsEnabled) {
                    gridLabelsEnabled = false;
                    clearGridLabels();
                }
            }
        }

        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            scene.add(camera);

            const canvas = document.getElementById('game-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const aLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(aLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -200;
            directionalLight.shadow.camera.right = 200;
            directionalLight.shadow.camera.top = 200;
            directionalLight.shadow.camera.bottom = -200;
            scene.add(directionalLight);

            createShovelModel();
            createPickaxeModel();
            createHandsModel();

            createWater();

            const highlightMat = new THREE.LineBasicMaterial({ color: 0xffffff, depthTest: false, transparent: true, opacity: 0.7 });
            const highlightGeo = new THREE.BufferGeometry();
            highlightGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(5 * 3), 3));
            selectionHighlight = new THREE.Line(highlightGeo, highlightMat);
            scene.add(selectionHighlight);
            selectionHighlight.visible = false;

            const adjBordersGeo = new THREE.BufferGeometry();
            adjBordersGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(24), 3));
            adjBordersGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(24), 3));
            adjacentBordersHighlight = new THREE.LineSegments(adjBordersGeo, new THREE.LineBasicMaterial({ 
                vertexColors: true, depthTest: false, transparent: true, opacity: 0.8 
            }));
            scene.add(adjacentBordersHighlight);
            adjacentBordersHighlight.visible = false;

            const adjTilesGeo = new THREE.BufferGeometry();
            adjTilesGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(64 * 3), 3));
            adjTilesGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(64 * 3), 3));
            adjacentTilesHighlight = new THREE.LineSegments(adjTilesGeo, new THREE.LineBasicMaterial({ 
                vertexColors: true, depthTest: false, transparent: true, opacity: 0.4 
            }));
            adjacentTilesHighlight.renderOrder = 997;
            scene.add(adjacentTilesHighlight);
            adjacentTilesHighlight.visible = false;

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onMouseWheel, { passive: false });
            
            window.addEventListener('blur', () => {
                keys = {};
                vx = 0;
                vz = 0;
            });

            animate();
            updateInventoryUI();
        }

        function createShovelModel() {
            shovelGroup = new THREE.Group();
            const metalColor = 0x6a94a2;
            const woodColor = 0x8b5a2b;
            const handleMat = new THREE.MeshLambertMaterial({ color: woodColor });
            const headMat = new THREE.MeshLambertMaterial({ color: metalColor });

            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.0, 8), handleMat);
            handle.rotation.z = Math.PI / 2;
            shovelGroup.add(handle);

            const shovelShape = new THREE.Shape();
            shovelShape.moveTo(0, -0.18);
            shovelShape.lineTo(0.25, -0.15);
            shovelShape.lineTo(0.35, 0);
            shovelShape.lineTo(0.25, 0.15);
            shovelShape.lineTo(0, 0.18);
            shovelShape.lineTo(0, -0.18);
            const head = new THREE.Mesh(new THREE.ExtrudeGeometry(shovelShape, { depth: 0.04, bevelEnabled: false }), headMat);
            head.position.set(0.45, -0.02, 0);
            head.rotation.x = Math.PI / 2;
            shovelGroup.add(head);

            shovelGroup.position.set(0.6, -0.7, -1.0);
            shovelGroup.rotation.y = -Math.PI / 3;
            shovelGroup.rotation.z = Math.PI / 8;
            camera.add(shovelGroup);
            shovelGroup.visible = false;
        }

        function createPickaxeModel() {
            pickaxeGroup = new THREE.Group();
            const metalColor = 0x555555;
            const woodColor = 0x8b5a2b;
            const handleMat = new THREE.MeshLambertMaterial({ color: woodColor });
            const headMat = new THREE.MeshLambertMaterial({ color: metalColor });

            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.0, 8), handleMat);
            handle.rotation.z = Math.PI / 2;
            pickaxeGroup.add(handle);

            const headGroup = new THREE.Group();
            headGroup.position.set(0.45, 0, 0);
            const center = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.07, 0.12), headMat);
            headGroup.add(center);

            const spikeGeo = new THREE.ConeGeometry(0.04, 0.35, 8);
            const spike1 = new THREE.Mesh(spikeGeo, headMat);
            spike1.position.set(0, 0, 0.2); spike1.rotation.x = Math.PI / 2;
            headGroup.add(spike1);

            const spike2 = new THREE.Mesh(spikeGeo, headMat);
            spike2.position.set(0, 0, -0.2); spike2.rotation.x = -Math.PI / 2;
            headGroup.add(spike2);
            pickaxeGroup.add(headGroup);

            pickaxeGroup.position.set(0.6, -0.7, -1.0);
            camera.add(pickaxeGroup);
            pickaxeGroup.visible = false;
        }

        function createHandsModel() {
            armsGroup = new THREE.Group();
            const skinColor = 0xe8beac;
            const sleeveColor = 0x2e4a39;
            const handMat = new THREE.MeshLambertMaterial({ color: skinColor });
            const sleeveMat = new THREE.MeshLambertMaterial({ color: sleeveColor });

            const rArm = new THREE.Group(); 
            rArm.name = "rightArm";
            rArm.add(new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.09, 0.6, 8), sleeveMat).rotateX(Math.PI/2));
            const rHand = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 0.18), handMat); 
            rHand.position.z = -0.35;
            rArm.add(rHand);
            rArm.position.set(0.3, -0.4, -0.5); 
            rArm.rotation.y = -0.1;
            armsGroup.add(rArm);

            const lArm = new THREE.Group(); 
            lArm.name = "leftArm";
            lArm.add(new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.09, 0.6, 8), sleeveMat).rotateX(Math.PI/2));
            const lHand = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 0.18), handMat); 
            lHand.position.z = -0.35;
            lArm.add(lHand);
            lArm.position.set(-0.3, -0.4, -0.5); 
            lArm.rotation.y = 0.1;
            armsGroup.add(lArm);

            camera.add(armsGroup);
            armsGroup.visible = false;
        }

        function updateInventoryUI() {
            updateGridVisibility();
            
            for (let i = 0; i < 6; i++) {
                const slot = document.getElementById(`slot-${i}`);
                if (slot) {
                    if (i === selectedSlot) slot.classList.add('active');
                    else slot.classList.remove('active');
                }
            }

            if (shovelGroup && pickaxeGroup && armsGroup) {
                const rArm = armsGroup.getObjectByName("rightArm");
                const lArm = armsGroup.getObjectByName("leftArm");

                shovelGroup.visible = false;
                pickaxeGroup.visible = false;

                if (selectedSlot === 1 && isFirstPerson) {
                    shovelGroup.visible = true;
                    shovelGroup.position.set(0.1, -0.85, -0.7);
                    shovelGroup.rotation.set(0.2, Math.PI / 1.8, 0.4);
                    if (rArm) { 
                        rArm.position.set(0.35, -0.5, -0.4); 
                        rArm.rotation.set(-0.2, -0.4, 0.1); 
                    }
                    if (lArm) { 
                        lArm.position.set(-0.1, -0.55, -0.6); 
                        lArm.rotation.set(0.3, 0.6, -0.1); 
                    }
                } else if (selectedSlot === 2 && isFirstPerson) {
                    pickaxeGroup.visible = true;
                    pickaxeGroup.position.set(0.1, -0.85, -0.7);
                    pickaxeGroup.rotation.set(0.2, Math.PI / 1.8, 0.4);
                    if (rArm) { 
                        rArm.position.set(0.35, -0.5, -0.4); 
                        rArm.rotation.set(-0.2, -0.4, 0.1); 
                    }
                    if (lArm) { 
                        lArm.position.set(-0.1, -0.55, -0.6); 
                        lArm.rotation.set(0.3, 0.6, -0.1); 
                    }
                } else {
                    if (rArm) { 
                        rArm.position.set(0.3, -0.4, -0.5); 
                        rArm.rotation.set(0, -0.1, 0); 
                    }
                    if (lArm) { 
                        lArm.position.set(-0.3, -0.4, -0.5); 
                        lArm.rotation.set(0, 0.1, 0); 
                    }
                }
            }
        }

        function createWater() {
            if (waterMesh) scene.remove(waterMesh);
            const geometry = new THREE.PlaneGeometry(mapSize * TILE_SIZE * 2, mapSize * TILE_SIZE * 2, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x006994,
                emissive: 0x001e33,
                specular: 0x111111,
                shininess: 50,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                flatShading: false
            });
            
            waterMesh = new THREE.Mesh(geometry, material);
            waterMesh.rotation.x = -Math.PI / 2;
            waterMesh.position.y = 1.5;
            waterMesh.position.x = (mapSize * TILE_SIZE) / 2;
            waterMesh.position.z = (mapSize * TILE_SIZE) / 2;
            
            scene.add(waterMesh);
        }

        function updateWater() {
            if (!waterMesh) return;
            const time = Date.now() * 0.00075;
            const positions = waterMesh.geometry.attributes.position;
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                
                const z = Math.sin(x * 0.03 + time) * 0.1 + 
                          Math.cos(y * 0.02 + time * 0.6) * 0.1;
                
                positions.setZ(i, z);
            }
            positions.needsUpdate = true;
            waterMesh.geometry.computeVertexNormals();
        }

        function createTerrain() {
            if (terrain) scene.remove(terrain);
            if (!heightMap || heightMap.length === 0) return;

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const indices = [];
            let vertexOffset = 0;

            for (let x = 0; x < mapSize - 1; x++) {
                for (let z = 0; z < mapSize - 1; z++) {
                    const h1 = heightMap[x][z] * METERS_PER_TERRA;
                    const h2 = heightMap[x + 1][z] * METERS_PER_TERRA;
                    const h3 = heightMap[x + 1][z + 1] * METERS_PER_TERRA;
                    const h4 = heightMap[x][z + 1] * METERS_PER_TERRA;

                    const type = terrainTypeMap[x][z];
                    const biome = biomeMap[x][z];
                    
                    let color;
                    
                    if (type === 5) {
                        color = { r: 0.5, g: 0.5, b: 0.5 };
                    } else if (type === 3) {
                        color = { r: 0.8, g: 0.75, b: 0.5 };
                    } else {
                        switch (biome) {
                            case BIOME_AMAZONIA:
                                color = { r: 0.1, g: 0.5, b: 0.1 };
                                if (type === 1) color = { r: 0.3, g: 0.4, b: 0.2 };
                                break;
                                
                            case BIOME_CERRADO:
                                color = { r: 0.4, g: 0.5, b: 0.2 };
                                if (type === 1) color = { r: 0.5, g: 0.4, b: 0.2 };
                                break;
                                
                            case BIOME_CAATINGA:
                                color = { r: 0.6, g: 0.5, b: 0.3 };
                                if (type === 2) color = { r: 0.5, g: 0.4, b: 0.2 };
                                break;
                                
                            case BIOME_MATA_ATLANTICA:
                                color = { r: 0.2, g: 0.6, b: 0.2 };
                                break;
                                
                            case BIOME_PAMPA:
                                color = { r: 0.3, g: 0.6, b: 0.3 };
                                break;
                                
                            case BIOME_PANTANAL:
                                color = { r: 0.2, g: 0.5, b: 0.4 };
                                break;
                                
                            case BIOME_COSTEIRA:
                                color = { r: 0.7, g: 0.8, b: 0.5 };
                                break;
                                
                            case BIOME_MONTANHA:
                                if (type === 4) {
                                    color = { r: 0.4, g: 0.35, b: 0.3 };
                                } else {
                                    color = { r: 0.3, g: 0.5, b: 0.3 };
                                }
                                break;
                                
                            default:
                                color = { r: 0.2, g: 0.6, b: 0.2 };
                                break;
                        }
                    }

                    vertices.push(x * TILE_SIZE, h1, z * TILE_SIZE);
                    vertices.push((x + 1) * TILE_SIZE, h2, z * TILE_SIZE);
                    vertices.push((x + 1) * TILE_SIZE, h3, (z + 1) * TILE_SIZE);
                    vertices.push(x * TILE_SIZE, h4, (z + 1) * TILE_SIZE);

                    for (let i = 0; i < 4; i++) colors.push(color.r, color.g, color.b);

                    indices.push(vertexOffset, vertexOffset + 2, vertexOffset + 1);
                    indices.push(vertexOffset, vertexOffset + 3, vertexOffset + 2);
                    vertexOffset += 4;
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const material = new THREE.MeshLambertMaterial({ vertexColors: true, side: THREE.DoubleSide });
            terrain = new THREE.Mesh(geometry, material);
            terrain.receiveShadow = true;
            scene.add(terrain);
        }

        function updateInventoryDisplay() {
            document.getElementById('inv-dirt').textContent = inventory.dirt;
            document.getElementById('inv-sand').textContent = inventory.sand;
            document.getElementById('inv-rock').textContent = inventory.rock;
        }

        function updateSlopeIndicator(slope) {
            const indicator = document.getElementById('slope-indicator');
            const normalizedSlope = Math.abs(Math.round(slope));
            
            let color = '#00ff00';
            if (normalizedSlope > CRITICAL_SLOPE) {
                color = '#ff0000';
            } else if (normalizedSlope > MAX_CLIMB_SLOPE) {
                color = '#ff9900';
            } else if (normalizedSlope > SLIP_START_SLOPE) {
                color = '#ffff00';
            }
            
            indicator.style.display = 'block';
            indicator.innerHTML = `<span style="color:${color}">Inclina√ß√£o: ${normalizedSlope} (${SLIP_START_SLOPE}/${MAX_CLIMB_SLOPE}/${CRITICAL_SLOPE})</span>`;
            
            const hud = document.getElementById('hud');
            const hudRect = hud.getBoundingClientRect();
            const tileInfo = document.getElementById('tile-info');
            const tileRect = tileInfo.getBoundingClientRect();
            
            indicator.style.top = (tileRect.bottom + 5) + 'px';
            indicator.style.left = hudRect.left + 'px';
        }

        function updateCamera() {
            cameraYaw = targetYaw;
            cameraPitch = targetPitch;
            cameraDistance += (targetDistance - cameraDistance) * cameraSmoothness;

            if (isFirstPerson) {
                camera.position.set(player.x, player.z + cameraHeight, player.y);
                const lookX = player.x + Math.cos(cameraPitch) * Math.sin(cameraYaw);
                const lookY = player.z + cameraHeight + Math.sin(cameraPitch);
                const lookZ = player.y + Math.cos(cameraPitch) * Math.cos(cameraYaw);
                camera.lookAt(lookX, lookY, lookZ);
            } else {
                const targetX = player.x;
                const targetY = player.z + cameraHeight;
                const targetZ = player.y;
                const offsetX = cameraDistance * Math.sin(cameraYaw) * Math.cos(cameraPitch);
                const offsetY = cameraDistance * Math.sin(cameraPitch);
                const offsetZ = cameraDistance * Math.cos(cameraYaw) * Math.cos(cameraPitch);
                camera.position.set(targetX - offsetX, targetY + offsetY, targetZ - offsetZ);
                camera.lookAt(targetX, targetY, targetZ);
            }
        }

        function updatePlayerMovement() {
            const terrainHeight = getHeightAt(player.x, player.y);
            const isGrounded = player.z <= terrainHeight + 0.05;

            let inputX = 0, inputZ = 0;
            characterYaw = cameraYaw;
            const sin = Math.sin(characterYaw), cos = Math.cos(characterYaw);
            const forward = { x: sin, z: cos }, right = { x: cos, z: -sin };

            if (keys['w'] || keys['W']) { inputX += forward.x; inputZ += forward.z; }
            if (keys['s'] || keys['S']) { inputX -= forward.x; inputZ -= forward.z; }
            if (keys['a'] || keys['A']) { inputX += right.x; inputZ += right.z; }
            if (keys['d'] || keys['D']) { inputX -= right.x; inputZ -= right.z; }

            const len = Math.sqrt(inputX * inputX + inputZ * inputZ);
            if (len > 0) { inputX /= len; inputZ /= len; }

            const isSprinting = keys['Shift'];
            const currentAccel = isSprinting ? acceleration * 3 : acceleration;
            let slopeSpeedMult = 1.0;

            if (len > 0 && isGrounded) {
                const stepSize = 0.5;
                const hAhead = getHeightAt(player.x + inputX * stepSize, player.y + inputZ * stepSize);
                currentSlope = ((hAhead - terrainHeight) / METERS_PER_TERRA) * (TILE_SIZE / stepSize);
                
                updateSlopeIndicator(currentSlope);
                
                if (currentSlope >= 0) {
                    slopeSpeedMult = Math.max(0.1, 1.0 - (currentSlope / 40));
                    terraformWarningShown = false;
                }
            } else {
                const indicator = document.getElementById('slope-indicator');
                indicator.style.display = 'none';
                terraformWarningShown = false;
            }

            const airControl = 0.4;
            const effectiveAccel = isGrounded ? currentAccel : currentAccel * airControl;

            if (len > 0) {
                vx += inputX * effectiveAccel * slopeSpeedMult;
                vz += inputZ * effectiveAccel * slopeSpeedMult;
            } else {
                const stopFriction = 0.88;
                vx *= stopFriction;
                vz *= stopFriction;
                
                if (Math.abs(vx) < 0.005) vx = 0;
                if (Math.abs(vz) < 0.005) vz = 0;
            }

            let currentFriction = isGrounded ? (len > 0 ? friction : 0.88) : 0.985;
            vx *= currentFriction;
            vz *= currentFriction;

            const worldSize = (mapSize - 1) * TILE_SIZE;

            const nextX = player.x + vx;
            if (nextX >= 0 && nextX < worldSize) {
                player.x = nextX;
            } else {
                vx = 0;
            }

            const nextZ = player.y + vz;
            if (nextZ >= 0 && nextZ < worldSize) {
                player.y = nextZ;
            } else {
                vz = 0;
            }

            const collidingTree = checkTreeCollision(player.x, player.y);
            if (collidingTree) {
                const dx = player.x - collidingTree.x;
                const dz = player.y - collidingTree.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const minDistance = 0.5 + (collidingTree.growth * 0.5);
                
                if (distance > 0 && distance < minDistance) {
                    const pushForce = (minDistance - distance) * 0.5;
                    player.x += (dx / distance) * pushForce;
                    player.y += (dz / distance) * pushForce;
                }
            }

            const currentTerrainHeight = getHeightAt(player.x, player.y);
            
            const checkRadius = 0.3;
            const hRight = getHeightAt(player.x + checkRadius, player.y);
            const hLeft = getHeightAt(player.x - checkRadius, player.y);
            const hForward = getHeightAt(player.x, player.y + checkRadius);
            const hBack = getHeightAt(player.x, player.y - checkRadius);
            
            const gradientX = (hLeft - hRight) / (checkRadius * 2);
            const gradientZ = (hBack - hForward) / (checkRadius * 2);
            const slopeMagnitude = Math.sqrt(gradientX * gradientX + gradientZ * gradientZ);
            
            const standingSlope = (slopeMagnitude / METERS_PER_TERRA) * TILE_SIZE;
            
            if (player.z <= currentTerrainHeight) {
                player.z = currentTerrainHeight;
                verticalVelocity = 0;
                
                const currentTime = Date.now();
                
                let slideForce = 0;
                let jumpMultiplier = 1.0;
                let warningMessage = "";
                
                if (standingSlope > SLIP_START_SLOPE && standingSlope <= MAX_CLIMB_SLOPE) {
                    const progress = (standingSlope - SLIP_START_SLOPE) / (MAX_CLIMB_SLOPE - SLIP_START_SLOPE);
                    slideForce = 0.5 + (progress * 0.5);
                    jumpMultiplier = 1.0 - (progress * 0.2);
                    warningMessage = "Terreno inclinado - cuidado ao andar.";
                } else if (standingSlope > MAX_CLIMB_SLOPE && standingSlope <= CRITICAL_SLOPE) {
                    const progress = (standingSlope - MAX_CLIMB_SLOPE) / (CRITICAL_SLOPE - MAX_CLIMB_SLOPE);
                    slideForce = 1.1 + (progress * 0.9);
                    jumpMultiplier = 0.8 - (progress * 0.7);
                    warningMessage = "Inclina√ß√£o muito alta! Voc√™ est√° escorregando!";
                } else if (standingSlope > CRITICAL_SLOPE) {
                    slideForce = 2.0;
                    jumpMultiplier = 0.1;
                    warningMessage = "Inclina√ß√£o extrema! Imposs√≠vel subir!";
                }
                
                if (slideForce > 0) {
                    const slideX = gradientX * slideForce * 0.012;
                    const slideZ = gradientZ * slideForce * 0.012;
                    
                    vx += slideX;
                    vz += slideZ;
                    
                    if (warningMessage && currentTime - lastWarningTime > WARNING_COOLDOWN) {
                        addChatMessage("Aviso", warningMessage);
                        lastWarningTime = currentTime;
                    }
                }
                
                if (keys[' '] && player.z <= currentTerrainHeight + 0.5) {
                    const effectiveJumpForce = baseJumpForce * jumpMultiplier;
                    if (effectiveJumpForce > 0.05) {
                        verticalVelocity = effectiveJumpForce;
                    }
                }
            } else {
                verticalVelocity -= gravity;
            }
            
            player.z += verticalVelocity;

            if (player.z < currentTerrainHeight) {
                player.z = currentTerrainHeight;
                verticalVelocity = 0;
            }

            document.getElementById('position-display').textContent = `X: ${player.x.toFixed(1)}, Y: ${player.y.toFixed(1)}, Z: ${player.z.toFixed(1)}`;
        }

        function getHeightAt(x, z) {
            if (!heightMap || heightMap.length === 0) return 0;
            const gx = x / TILE_SIZE;
            const gz = z / TILE_SIZE;
            const ix = Math.floor(gx);
            const iz = Math.floor(gz);
            const fx = gx - ix;
            const fz = gz - iz;

            if (ix < 0 || ix >= mapSize - 1 || iz < 0 || iz >= mapSize - 1) return 0;

            const h00 = heightMap[ix][iz];
            const h10 = heightMap[ix + 1][iz];
            const h01 = heightMap[ix][iz + 1];
            const h11 = heightMap[ix + 1][iz + 1];

            const hX0 = h00 * (1 - fx) + h10 * fx;
            const hX1 = h01 * (1 - fx) + h11 * fx;
            return (hX0 * (1 - fz) + hX1 * fz) * METERS_PER_TERRA;
        }

        function applyTerraform(target, actionType) {
            const { x, y, mode } = target;
            const tx = x, ty = y;
            let droppedMaterialType = -1;

            if (mode === 'corner') {
                if (tx >= 0 && tx < mapSize && ty >= 0 && ty < mapSize) {
                    const currentH = heightMap[tx][ty];
                    const rockH = rockHeightMap[tx][ty];
                    let newH = currentH;

                    if (actionType === 'dig') {
                        if (currentH > rockH) {
                            newH = currentH - 1;
                            const currentType = terrainTypeMap[Math.min(tx, mapSize-2)][Math.min(ty, mapSize-2)];
                            if (currentType === 3) {
                                inventory.sand++;
                                addChatMessage("A√ß√£o", "Voc√™ cavou areia.");
                            } else {
                                inventory.dirt++;
                                addChatMessage("A√ß√£o", "Voc√™ cavou terra.");
                            }
                        } else {
                            addChatMessage("Aviso", "Voc√™ atingiu a rocha s√≥lida.");
                            return;
                        }
                    } else if (actionType === 'pack') {
                        newH = currentH + 1;
                        if (inventory.dirt > 0) {
                            inventory.dirt--;
                            droppedMaterialType = 1;
                            addChatMessage("A√ß√£o", "Voc√™ soltou terra no ch√£o.");
                        } else if (inventory.sand > 0) {
                            inventory.sand--;
                            droppedMaterialType = 3;
                            addChatMessage("A√ß√£o", "Voc√™ soltou areia no ch√£o.");
                        }
                    } else if (actionType === 'mine') {
                        if (currentH <= rockH) {
                            const neighbors = [[tx+1, ty], [tx-1, ty], [tx, ty+1], [tx, ty-1]];
                            let canMine = true;
                            for(let n of neighbors) {
                                if(n[0]>=0 && n[0]<mapSize && n[1]>=0 && n[1]<mapSize) {
                                    if (heightMap[n[0]][n[1]] > rockHeightMap[n[0]][n[1]]) {
                                        canMine = false; break;
                                    }
                                }
                            }
                            if (!canMine) {
                                addChatMessage("Erro", "Limpe a terra ao redor antes de minerar.");
                                return;
                            }
                            rockHeightMap[tx][ty] -= 1;
                            newH = currentH - 1;
                            inventory.rock++;
                            addChatMessage("A√ß√£o", "Voc√™ minerou fragmentos de pedra.");
                        }
                    }

                    heightMap[tx][ty] = newH;
                }
                
                const tilesToUpdate = [];
                if (x < mapSize - 1 && y < mapSize - 1) tilesToUpdate.push({ x, y });
                if (x > 0 && y < mapSize - 1) tilesToUpdate.push({ x: x - 1, y });
                if (x < mapSize - 1 && y > 0) tilesToUpdate.push({ x, y: y - 1 });
                if (x > 0 && y > 0) tilesToUpdate.push({ x: x - 1, y: y - 1 });

                tilesToUpdate.forEach(t => {
                    const prevType = terrainTypeMap[t.x][t.y];
                    const c1 = heightMap[t.x][t.y] === rockHeightMap[t.x][t.y];
                    const c2 = heightMap[t.x + 1][t.y] === rockHeightMap[t.x + 1][t.y];
                    const c3 = heightMap[t.x][t.y + 1] === rockHeightMap[t.x][t.y + 1];
                    const c4 = heightMap[t.x + 1][t.y + 1] === rockHeightMap[t.x + 1][t.y + 1];

                    let newType = prevType;
                    if (c1 && c2 && c3 && c4) newType = 5;
                    else {
                        if (actionType === 'pack' && droppedMaterialType !== -1) newType = droppedMaterialType;
                        else if (prevType === 0 && actionType === 'dig') newType = 1;
                        else if (prevType === 5 && actionType === 'pack') newType = droppedMaterialType;
                    }
                    terrainTypeMap[t.x][t.y] = newType;

                    if (newType === 1 || newType === 2) {
                        dirtTimestamps[`${t.x},${t.y}`] = Date.now();
                    }
                });

                if (gridLabelsEnabled) {
                    updateGridLabelsAfterTerraform(tx, ty);
                }
            }

            updateInventoryDisplay();
            createTerrain();
        }

        function startAction(name, duration, onComplete) {
            if (currentAction) return;

            currentAction = {
                name: name,
                startTime: Date.now(),
                duration: duration,
                onComplete: onComplete
            };

            document.getElementById('action-bar-container').style.display = 'block';
            document.getElementById('action-text').textContent = name;
        }

        function updateAction() {
            if (!currentAction) return;

            const elapsed = Date.now() - currentAction.startTime;
            const progress = Math.min(100, (elapsed / currentAction.duration) * 100);
            document.getElementById('action-bar-fill').style.width = progress + '%';

            if (elapsed >= currentAction.duration) {
                currentAction.onComplete();
                cancelAction();
            }
        }

        function cancelAction() {
            currentAction = null;
            document.getElementById('action-bar-container').style.display = 'none';
            document.getElementById('action-bar-fill').style.width = '0%';
        }

        function validateTerraform(target, actionType) {
            const { x, y } = target;
            if (x < 0 || x >= mapSize || y < 0 || y >= mapSize) return false;

            const currentH = heightMap[x][y];
            const rockH = rockHeightMap[x][y];
            let newH = currentH;

            if (actionType === 'dig') {
                if (currentH <= rockH) {
                    return false;
                }
                newH = currentH - 1;
            } else if (actionType === 'pack') {
                newH = currentH + 1;
            } else if (actionType === 'mine') {
                if (currentH > rockH) {
                    return false;
                }
                const neighbors = [[x+1, y], [x-1, y], [x, y+1], [x, y-1]];
                let canMine = true;
                for(let n of neighbors) {
                    if(n[0]>=0 && n[0]<mapSize && n[1]>=0 && n[1]<mapSize) {
                        if (heightMap[n[0]][n[1]] > rockHeightMap[n[0]][n[1]]) {
                            canMine = false; break;
                        }
                    }
                }
                if (!canMine) {
                    return false;
                }
                newH = currentH - 1;
            }

            return true;
        }

        function handleTerraforming() {
            if (selectedSlot === 3) {
                if (mouseDown.left && selectedTree) {
                    if (!currentAction) {
                        startAction("Cortando √°rvore...", 2000, () => {
                            if (chopTree(selectedTree)) {
                                updateTreeSelection();
                            }
                        });
                    }
                }
            } else if (selectedSlot === 4) {
                if (mouseDown.left && terraformTarget.valid) {
                    const worldX = terraformTarget.x * TILE_SIZE;
                    const worldZ = terraformTarget.y * TILE_SIZE;
                    const biome = biomeMap[terraformTarget.x][terraformTarget.y];
                    
                    if (isTileOccupied(worldX, worldZ)) {
                        addChatMessage("Plantio", "J√° existe uma √°rvore ou muda neste tile.");
                        return;
                    }

                    if (inventory.saplings <= 0 && inventory.seeds <= 0) {
                        addChatMessage("Invent√°rio", "Voc√™ precisa de sementes ou mudas para plantar!");
                        return;
                    }

                    if (!currentAction) {
                        startAction("Plantando...", 3000, () => {
                            if (inventory.saplings > 0) {
                                inventory.saplings--;
                                createSeedling(worldX, worldZ, biome);
                                addChatMessage("Sistema", "Muda plantada com sucesso!");
                            } else if (inventory.seeds > 0) {
                                inventory.seeds--;
                                const seedling = createSeedling(worldX, worldZ, biome);
                                seedling.growth = 0.05;
                                addChatMessage("Sistema", "Semente plantada!");
                            }
                            updateTreeInventoryDisplay();
                        });
                    }
                }
            } else if (selectedSlot === 5) {
                if (mouseDown.left && selectedTree) {
                    if (!currentAction) {
                        startAction("Coletando sementes...", 1000, () => {
                            inventory.seeds += TREE_TYPES[selectedTree.type].seedCount;
                            updateTreeInventoryDisplay();
                            addChatMessage("Recurso", `+${TREE_TYPES[selectedTree.type].seedCount} sementes coletadas`);
                        });
                    }
                }
            } else {
                if (!mouseDown.left && !mouseDown.right) {
                    if (currentAction) cancelAction();
                    return;
                }
                if (!terraformTarget.valid) return;
                if (currentAction) return;

                if (selectedSlot === 1) {
                    if (mouseDown.left) {
                        if (validateTerraform(terraformTarget, 'dig')) {
                            startAction("Cavando...", 1000, () => applyTerraform(terraformTarget, 'dig'));
                        }
                    } else if (mouseDown.right) {
                        if (inventory.dirt > 0 || inventory.sand > 0) {
                            if (validateTerraform(terraformTarget, 'pack')) {
                                startAction("Nivelando...", 1500, () => applyTerraform(terraformTarget, 'pack'));
                            }
                        } else {
                            addChatMessage("Invent√°rio", "Voc√™ precisa de terra ou areia.");
                        }
                    }
                } else if (selectedSlot === 2) {
                    if (mouseDown.left) {
                        if (validateTerraform(terraformTarget, 'mine')) {
                            startAction("Minerando...", 2000, () => applyTerraform(terraformTarget, 'mine'));
                        }
                    }
                }
            }
        }

        function updateSelectionCursor() {
            if (!selectionHighlight || !terrain || !heightMap) return;
            selectionHighlight.visible = false;
            terraformTarget.valid = false;
            if (adjacentBordersHighlight) adjacentBordersHighlight.visible = false;
            if (adjacentTilesHighlight) adjacentTilesHighlight.visible = false;
            hideCursorLabel();

            updateTreeSelection();

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObject(terrain);

            if (intersects.length === 0 || intersects[0].distance > 12) return;

            const rx = Math.round(intersects[0].point.x / TILE_SIZE);
            const rz = Math.round(intersects[0].point.z / TILE_SIZE);

            if (rx >= 0 && rx < mapSize && rz >= 0 && rz < mapSize) {
                terraformTarget = { x: rx, y: rz, valid: true, mode: 'corner' };
                
                const h = heightMap[rx][rz];
                const cx = rx * TILE_SIZE;
                const cz = rz * TILE_SIZE;
                const ch = h * METERS_PER_TERRA + 0.05;

                if (selectedSlot === 1 || selectedSlot === 2) {
                    drawAdjacentBorders(rx, rz);
                    drawAdjacentTiles(rx, rz);
                    
                    if (gridLabelsEnabled) {
                        updateGridLabelsForAdjacentArea(rx, rz);
                    }
                } else if (gridLabelsEnabled) {
                    clearGridLabels();
                }

                let labelText = `H: ${h}`;
                if (h <= rockHeightMap[rx][rz]) labelText += " (Rocha)";
                
                if (selectedSlot === 1 || selectedSlot === 2) {
                    let maxS = 0;
                    const neighbors = [[rx+1, rz], [rx-1, rz], [rx, rz+1], [rx, rz-1]];
                    for(let n of neighbors) {
                        if(n[0]>=0 && n[0]<mapSize && n[1]>=0 && n[1]<mapSize) {
                            const diff = Math.abs(heightMap[n[0]][n[1]] - h);
                            if(diff > maxS) maxS = diff;
                        }
                    }
                    labelText += ` | Inclina√ß√£o: ${maxS}/${worldConfig.maxSlope}`;
                }

                showCustomLabel(cx, ch + 1, cz, labelText);
            } else if (gridLabelsEnabled) {
                clearGridLabels();
            }
        }

        function showCustomLabel(x, y, z, text, color = '#fff') {
            const el = document.getElementById('cursor-label');
            const screenPos = toScreenPosition(new THREE.Vector3(x, y, z));
            if (screenPos.visible) {
                el.style.display = 'block';
                el.style.left = screenPos.x + 'px';
                el.style.top = screenPos.y + 'px';
                el.textContent = text;
                el.style.color = color;
            } else {
                el.style.display = 'none';
            }
        }

        function hideCursorLabel() {
            document.getElementById('cursor-label').style.display = 'none';
        }

        function drawAdjacentBorders(cx, cz) {
            if (!adjacentBordersHighlight) return;
            const positions = adjacentBordersHighlight.geometry.attributes.position.array;
            const colors = adjacentBordersHighlight.geometry.attributes.color.array;
            let idx = 0, colorIdx = 0;
            const borders = [
                { x1: cx, z1: cz, x2: cx, z2: cz - 1 },
                { x1: cx, z1: cz, x2: cx, z2: cz + 1 },
                { x1: cx, z1: cz, x2: cx + 1, z2: cz },
                { x1: cx, z1: cz, x2: cx - 1, z2: cz }
            ];

            let r = 1, g = 1, b = 1;
            if (selectedSlot === 1) { r = 0; g = 1; b = 0; }
            else if (selectedSlot === 2) { r = 1; g = 0.5; b = 0; }

            borders.forEach(b => {
                if (b.x1 >= 0 && b.x1 < mapSize && b.z1 >= 0 && b.z1 < mapSize && b.x2 >= 0 && b.x2 < mapSize && b.z2 >= 0 && b.z2 < mapSize) {
                    const h1 = heightMap[b.x1][b.z1] * METERS_PER_TERRA + 0.05;
                    const h2 = heightMap[b.x2][b.z2] * METERS_PER_TERRA + 0.05;
                    const wx1 = b.x1 * TILE_SIZE, wz1 = b.z1 * TILE_SIZE;
                    const wx2 = b.x2 * TILE_SIZE, wz2 = b.z2 * TILE_SIZE;
                    
                    positions[idx++] = wx1; positions[idx++] = h1; positions[idx++] = wz1;
                    positions[idx++] = wx2; positions[idx++] = h2; positions[idx++] = wz2;
                    
                    for(let k=0; k<2; k++) { colors[colorIdx++] = r; colors[colorIdx++] = g; colors[colorIdx++] = b; }
                }
            });
            adjacentBordersHighlight.geometry.setDrawRange(0, idx / 3);
            adjacentBordersHighlight.geometry.attributes.position.needsUpdate = true;
            adjacentBordersHighlight.geometry.attributes.color.needsUpdate = true;
            adjacentBordersHighlight.visible = true;
        }

        function drawAdjacentTiles(cx, cz) {
            if (!adjacentTilesHighlight) return;
            const positions = adjacentTilesHighlight.geometry.attributes.position.array;
            const colors = adjacentTilesHighlight.geometry.attributes.color.array;
            let idx = 0, colorIdx = 0;

            const tiles = [
                { x: cx - 1, y: cz - 1 },
                { x: cx, y: cz - 1 },
                { x: cx - 1, y: cz },
                { x: cx, y: cz }
            ];

            let r = 0.5, g = 0.5, b = 0.5;
            if (selectedSlot === 1) { r = 0; g = 0.5; b = 0; }
            else if (selectedSlot === 2) { r = 0.5; g = 0.2; b = 0; }

            tiles.forEach(t => {
                if (t.x >= 0 && t.x < mapSize - 1 && t.y >= 0 && t.y < mapSize - 1) {
                    const h00 = heightMap[t.x][t.y] * METERS_PER_TERRA + 0.05;
                    const h10 = heightMap[t.x + 1][t.y] * METERS_PER_TERRA + 0.05;
                    const h11 = heightMap[t.x + 1][t.y + 1] * METERS_PER_TERRA + 0.05;
                    const h01 = heightMap[t.x][t.y + 1] * METERS_PER_TERRA + 0.05;

                    const addLine = (x1, y1, z1, x2, y2, z2) => {
                        positions[idx++] = x1 * TILE_SIZE; positions[idx++] = y1; positions[idx++] = z1 * TILE_SIZE;
                        positions[idx++] = x2 * TILE_SIZE; positions[idx++] = y2; positions[idx++] = z2 * TILE_SIZE;
                        for(let k=0; k<2; k++) { colors[colorIdx++] = r; colors[colorIdx++] = g; colors[colorIdx++] = b; }
                    };

                    addLine(t.x, h00, t.y, t.x + 1, h10, t.y);
                    addLine(t.x + 1, h10, t.y, t.x + 1, h11, t.y + 1);
                    addLine(t.x + 1, h11, t.y + 1, t.x, h01, t.y + 1);
                    addLine(t.x, h01, t.y + 1, t.x, h00, t.y);
                }
            });

            adjacentTilesHighlight.geometry.setDrawRange(0, idx / 3);
            adjacentTilesHighlight.geometry.attributes.position.needsUpdate = true;
            adjacentTilesHighlight.geometry.attributes.color.needsUpdate = true;
            adjacentTilesHighlight.visible = true;
        }

        function toScreenPosition(vector) {
            const v = vector.clone();
            v.project(camera);
            const widthHalf = window.innerWidth / 2;
            const heightHalf = window.innerHeight / 2;
            return {
                x: (v.x * widthHalf) + widthHalf,
                y: -(v.y * heightHalf) + heightHalf,
                visible: v.z < 1
            };
        }

        function getRegionName(tx, ty) {
            const nx = tx / mapSize;
            const ny = ty / mapSize;
            const regionInfo = getBrazilRegionAndBiome(nx, ny);
            
            const subregionNames = {
                'RIO_AMAZONAS': 'Vale do Rio Amazonas',
                'PLANALTO_GUIANAS': 'Planalto das Guianas',
                'FLORESTA_AMAZONICA': 'Floresta Amaz√¥nica',
                'LITORAL': 'Litoral Nordestino',
                'CHAPADA_DIAMANTINA': 'Chapada Diamantina',
                'SERTAO': 'Sert√£o Nordestino',
                'PANTANAL': 'Pantanal',
                'CHAPADA_VEADEIROS': 'Chapada dos Veadeiros',
                'CERRADO': 'Cerrado',
                'SERRA_DO_MAR': 'Serra do Mar',
                'SERRA_MANTIQUEIRA': 'Serra da Mantiqueira',
                'PLANALTO_ATLANTICO': 'Planalto Atl√¢ntico',
                'SERRA_GERAL': 'Serra Geral',
                'PAMPA': 'Pampa',
                'PLANALTO_MERIDIONAL': 'Planalto Meridional',
                'ATLANTICO': 'Oceano Atl√¢ntico'
            };
            
            const regionNames = {
                'NORTE': 'Regi√£o Norte',
                'NORDESTE': 'Regi√£o Nordeste',
                'CENTRO_OESTE': 'Regi√£o Centro-Oeste',
                'SUDESTE': 'Regi√£o Sudeste',
                'SUL': 'Regi√£o Sul',
                'OCEANO': 'Oceano Atl√¢ntico'
            };
            
            return `${regionNames[regionInfo.region]} - ${subregionNames[regionInfo.subregion]}`;
        }

        function addChatMessage(name, msg) {
            const chatMessages = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = 'chat-message';
            div.innerHTML = `<strong>${name}:</strong> ${msg}`;
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function openChat() {
            chatOpen = true; keys = {};
            vx = 0; vz = 0;
            document.getElementById('chat-input-container').style.display = 'flex';
            document.getElementById('chat-input').focus();
            document.body.style.cursor = 'default';
        }

        function closeChat() {
            chatOpen = false;
            document.getElementById('chat-input-container').style.display = 'none';
            document.getElementById('chat-input').value = '';
            document.body.style.cursor = 'default';
            document.getElementById('game-canvas').requestPointerLock();
        }

        document.getElementById('chat-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const msg = e.target.value.trim();
                if (msg) addChatMessage(player.name, msg);
                closeChat();
            }
        });

        function openMenu() {
            menuOpen = true; keys = {};
            vx = 0; vz = 0;
            document.getElementById('menu').style.display = 'flex';
            document.body.style.cursor = 'default';
            document.exitPointerLock();
        }

        function closeMenu() {
            menuOpen = false;
            document.getElementById('menu').style.display = 'none';
        }

        function initPointerLock() {
            const canvas = document.getElementById('game-canvas');
            canvas.addEventListener('click', () => {
                if (!chatOpen && !menuOpen) canvas.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    closeMenu();
                } else {
                    if (!chatOpen) openMenu();
                }
            });
        }
        initPointerLock();

        function onKeyDown(e) {
            if (e.key === 'Escape') {
                if (chatOpen) closeChat();
                else if (menuOpen) { 
                    document.getElementById('game-canvas').requestPointerLock(); 
                    closeMenu(); 
                }
                return;
            }
            if (chatOpen) return;
            keys[e.key] = true;
            if (e.key === 'Enter') { 
                e.preventDefault(); 
                openChat(); 
            }
        }

        function onKeyUp(e) { 
            const key = e.key.toLowerCase();
            keys[e.key] = false;
            
            if (key === 'w' || key === 's' || key === 'a' || key === 'd') {
                if (key === 'w') { keys['w'] = false; keys['W'] = false; }
                if (key === 's') { keys['s'] = false; keys['S'] = false; }
                if (key === 'a') { keys['a'] = false; keys['A'] = false; }
                if (key === 'd') { keys['d'] = false; keys['D'] = false; }
            }
        }

        function onMouseDown(e) { 
            if (e.button === 0) mouseDown.left = true; 
            if (e.button === 2) mouseDown.right = true; 
        }

        function onMouseUp(e) { 
            if (e.button === 0) mouseDown.left = false; 
            if (e.button === 2) mouseDown.right = false; 
        }
        
        function onMouseMove(e) {
            if (chatOpen || menuOpen || !document.pointerLockElement) return;
            const sens = 0.0015;
            targetYaw -= e.movementX * sens;
            targetPitch -= e.movementY * sens;
            targetPitch = Math.max(minPitch, Math.min(maxPitch, targetPitch));
        }

        function onMouseWheel(e) {
            if (menuOpen || chatOpen) return;
            if (e.deltaY > 0) selectedSlot = (selectedSlot + 1) % 6;
            else selectedSlot = (selectedSlot - 1 + 6) % 6;
            updateInventoryUI();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateSlopeIndicator(currentSlope);
            if (gridLabelsEnabled) updateGridLabelsForAdjacentArea(currentGridCenter.x, currentGridCenter.y);
        }

        document.addEventListener('contextmenu', e => e.preventDefault());

        function animate() {
            requestAnimationFrame(animate);
            
            if (!chatOpen && !menuOpen) {
                updatePlayerMovement();
                updateSelectionCursor();
                handleTerraforming();
                updateAction();
                updateInventoryDisplay();
                updateTileInfo();
                updateWater();
                
                if (gridLabelsEnabled) {
                    updateVisibleGridLabels();
                }
            }
            
            updateCamera();
            
            if (isFirstPerson && (armsGroup || shovelGroup)) {
                const time = Date.now() * 0.005;
                const currentSpeed = Math.sqrt(vx * vx + vz * vz);
                const bobIntensity = currentSpeed > 0.1 ? Math.min(currentSpeed * 0.05, 0.03) : 0.005;
                const bobFreq = currentSpeed > 0.1 ? 2 : 1;
                const bobY = Math.sin(time * bobFreq) * bobIntensity;
                const bobX = Math.cos(time * bobFreq * 0.5) * bobIntensity * 0.5;

                if (armsGroup) {
                    armsGroup.position.y += ((0 + bobY) - armsGroup.position.y) * 0.1;
                    armsGroup.position.x += (bobX - armsGroup.position.x) * 0.1;
                }
                if (shovelGroup && selectedSlot === 1) {
                    shovelGroup.position.y += ((-0.85 + bobY) - shovelGroup.position.y) * 0.1;
                    shovelGroup.position.x += ((0.1 + bobX) - shovelGroup.position.x) * 0.1;
                }
                if (pickaxeGroup && selectedSlot === 2) {
                    pickaxeGroup.position.y += ((-0.85 + bobY) - pickaxeGroup.position.y) * 0.1;
                    pickaxeGroup.position.x += ((0.1 + bobX) - pickaxeGroup.position.x) * 0.1;
                }
            }

            renderer.render(scene, camera);
        }

        function updateTileInfo() {
            if (!terrain) return;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObject(terrain);
            const tileInfo = document.getElementById('tile-info');

            if (intersects.length > 0) {
                const p = intersects[0].point;
                const tx = Math.floor(p.x / TILE_SIZE);
                const ty = Math.floor(p.z / TILE_SIZE);

                if (tx >= 0 && tx < mapSize - 1 && ty >= 0 && ty < mapSize - 1) {
                    const type = terrainTypeMap[tx][ty];
                    let name = "Desconhecido";
                    if (type === 0) name = "Grama";
                    else if (type === 1) name = "Terra";
                    else if (type === 2) name = "Terra Compactada";
                    else if (type === 3) name = "Areia";
                    else if (type === 4) name = "Argila";
                    else if (type === 5) name = "Rocha";
                    
                    const regionName = getRegionName(tx, ty);
                    
                    tileInfo.textContent = `Olhando: ${name} [${tx}, ${ty}] - ${regionName}`;
                    return;
                }
            }
            tileInfo.textContent = "Olhando: -";
        }

        setInterval(() => {
            if (!worldConfig.autoReforestation) return;
            
            const now = Date.now();
            let updated = false;
            for (let x = 0; x < mapSize - 1; x++) {
                for (let y = 0; y < mapSize - 1; y++) {
                    if (terrainTypeMap[x] && terrainTypeMap[x][y] === 1) {
                        const key = `${x},${y}`;
                        const timestamp = dirtTimestamps[key] || 0;
                        const baseWaitTime = 60000;
                        const totalWaitTime = baseWaitTime + (compactionMap[x][y] || 0);

                        if (now - timestamp >= totalWaitTime) {
                            let hasAdjacentGrass = false;
                            const neighbors = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]];
                            for (const [nx, ny] of neighbors) {
                                if (nx < 0 || nx >= mapSize - 1 || ny < 0 || ny >= mapSize - 1) {
                                    hasAdjacentGrass = true; break;
                                } else if (terrainTypeMap[nx][ny] === 0) {
                                    hasAdjacentGrass = true; break;
                                }
                            }

                            if (hasAdjacentGrass) {
                                terrainTypeMap[x][y] = 0;
                                delete dirtTimestamps[key];
                                compactionMap[x][y] = 0;
                                updated = true;
                            }
                        }
                    }
                }
            }
            if (updated && typeof createTerrain === 'function') createTerrain();
        }, 5000);

        window.treeCommands = {
            addTree: function(x, z, type = 'AMAZON') {
                const tree = createTreeAt(x, z, BIOME_AMAZONIA);
                tree.type = type;
                return tree;
            },
            getTreeCount: function() {
                return trees.length;
            },
            getSeason: function() {
                return currentSeason.name;
            },
            setSeason: function(seasonName) {
                const season = Object.values(SEASONS).find(s => s.name === seasonName);
                if (season) {
                    currentSeason = season;
                    updateAllTreesSeasonalEffects();
                }
            }
        };

        setTimeout(() => {
            addChatMessage("SISTEMA", "üå≥ Sistema de √Årvores carregado!");
            addChatMessage("SISTEMA", "Use a roda do mouse para selecionar ferramentas de √°rvores");
            addChatMessage("SISTEMA", "Machado (ü™ì), Plantador (üå±), Coletor (üå∞)");
        }, 2000);

    </script>
</body>
</html>
